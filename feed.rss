<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Another Swift Blog</title><description>Another Swift Blog</description><link>https://tprezioso.github.io/</link><language>en</language><lastBuildDate>Sun, 24 Sep 2023 12:13:38 -0400</lastBuildDate><pubDate>Sun, 24 Sep 2023 12:13:38 -0400</pubDate><ttl>250</ttl><atom:link href="https://tprezioso.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2021/2021-10-01-how-to-know-when-your-app-becomes-active-or-inactive-in-swiftui</guid><title>How to Know When Your App Becomes Active or Inactive in SwiftUI</title><description></description><link>https://tprezioso.github.io/posts/2021/2021-10-01-how-to-know-when-your-app-becomes-active-or-inactive-in-swiftui</link><pubDate>Fri, 1 Oct 2021 01:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>How to Know When Your App Becomes Active or Inactive in SwiftUI</h1><p>Recently I was working on a SwiftUI project were I needed to know when my app became active from being in the background. Like most things in SwiftUI, I found out that this was really simple to implement in my project.</p><p>In SwiftUI we have a environment element called <strong><a href="https://developer.apple.com/documentation/swiftui/scenephase">scenePhase</a></strong>. What <strong></strong><a href="https://developer.apple.com/documentation/swiftui/scenephase">scenePhase</a><strong></strong> allows us to do is monitor if the app is Active, Inactive, or in the Background. Lets take a look at how we can use this in our project.</p><p>The first thing we will need to do is add the following variable to your code:</p><pre><code><span class="keyword">@Environment</span>(\.<span class="property">scenePhase</span>) <span class="keyword">var</span> scenePhase
</code></pre><p>This Environment variable is the key to monitoring what state your app is in. Next we will add an <strong>.onChange</strong> modifier to our view. This will allow us to see when our apps state has changed and then act on that change. Let‚Äôs now take a look at how I used the <strong></strong><a href="https://developer.apple.com/documentation/swiftui/scenephase">scenePhase</a><strong></strong> variable to reload a specific view when my app became active again.</p><pre><code><span class="keyword">struct</span> TodayWatchView: <span class="type">View</span> {
    <span class="keyword">@StateObject var</span> viewModel = <span class="type">TodayWatchViewModel</span>()
    
    <span class="comment">// 1) added scenePhase variable</span>
    <span class="keyword">@Environment</span>(\.<span class="property">scenePhase</span>) <span class="keyword">var</span> scenePhase
    
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">ZStack</span> {
            <span class="type">VStack</span> {
                <span class="keyword">if</span> !viewModel.<span class="property">isHolidaysEmpty</span> {
                    <span class="type">List</span>(viewModel.<span class="property">holidays</span>) { holiday <span class="keyword">in
                        if</span> holiday.<span class="property">url</span> == <span class="string">""</span> {
                            <span class="type">Text</span>(<span class="string">"</span>\(holiday.<span class="property">name</span>)<span class="string">"</span>)
                                .<span class="call">font</span>(.<span class="dotAccess">headline</span>)
                                .<span class="call">bold</span>()
                        } <span class="keyword">else</span> {
                            <span class="type">NavigationLink</span>(holiday.<span class="property">name</span>, destination: <span class="type">HolidayWatchDetailView</span>(holiday: holiday))
                        }
                    }
                } <span class="keyword">else</span> {
                    <span class="type">EmptyState</span>(message: <span class="string">"There was an issue loading Today's Holidays!\n Try again later"</span>)
                }
            }
            
            <span class="comment">// 2)
            // Reload data when app becomes active!!</span>
            .<span class="call">onChange</span>(of: scenePhase) { newPhase <span class="keyword">in
                if</span> newPhase == .<span class="dotAccess">inactive</span> {
                    <span class="call">print</span>(<span class="string">"Inactive"</span>)
                } <span class="keyword">else if</span> newPhase == .<span class="dotAccess">active</span> {
                    viewModel.<span class="call">getHolidays</span>()
                } <span class="keyword">else if</span> newPhase == .<span class="dotAccess">background</span> {
                    <span class="call">print</span>(<span class="string">"Background"</span>)
                }
            }
            .<span class="call">navigationTitle</span>(<span class="string">"Today Is...."</span>)
            .<span class="call">alert</span>(item: <span class="property">$viewModel</span>.<span class="property">alertItem</span>) { alertItem <span class="keyword">in</span>
                <span class="type">Alert</span>.<span class="keyword">init</span>(title: alertItem.<span class="property">title</span>, message: alertItem.<span class="property">message</span>, dismissButton: alertItem.<span class="property">dismissButton</span>)
            }
            .<span class="call">onAppear</span> {
                viewModel.<span class="call">getHolidays</span>()
            }
            <span class="keyword">if</span> viewModel.<span class="property">isLoading</span> {
                <span class="type">ProgressView</span>()
                    .<span class="call">progressViewStyle</span>(<span class="type">CircularProgressViewStyle</span>(tint: .<span class="dotAccess">gray</span>))
                    .<span class="call">scaleEffect</span>(<span class="number">2</span>, anchor: .<span class="dotAccess">center</span>)
            }
        }
    }
}
</code></pre><p>I hope this gives you a better understanding of how you can monitor your app and run functions depending on your apps state.</p><p>Thanks for reading and happy coding!!! üë®üèª‚Äçüíªüë®üèª‚Äçüíªüë®üèª‚Äçüíª</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2021/2021-09-18-failed-to-initialize-client-context-with-error-a-error-when-trying-to-run-a-widget-in-the-xcode-simulator-m1-macs</guid><title>"'Failed to initialize client context with error': A Error When Trying to Run a Widget in the Xcode Simulator (M1 Macs)"</title><description></description><link>https://tprezioso.github.io/posts/2021/2021-09-18-failed-to-initialize-client-context-with-error-a-error-when-trying-to-run-a-widget-in-the-xcode-simulator-m1-macs</link><pubDate>Sat, 18 Sep 2021 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>'Failed to initialize client context with error': A Error When Trying to Run a Widget in the Xcode Simulator (M1 Macs)</h1><p>This is a short post about an issue I recently had with updating a widget for a SwiftUI project. I kept getting a weird error every time I tried to run a widget target in the simulator. The error read "<strong>Failed to initialize client context with error</strong>". This was followed by a crazy long error message spit out by the debug console in Xcode. I googled everything and I finally found the solution! (<strong>Note: This only happened on my M1 Mac</strong>)</p><p>What you need to do to fix this error is toggle off the "<strong>Open using Rosetta</strong>" button. To do that you need to right click on the Xcode app icon and go to <strong>"Get Info"</strong>. In the Get Info window you are going to want to toggle off the "<strong>Open using Rosetta</strong>" button. Now if you quit Xcode and reopen, you shouldn't see that error pop up again. Go re-run the widget in the simulator and VOIL√Ä!</p><p>Until Apple fixes all the weird errors with supporting both <strong>Intel</strong> and <strong>M1</strong> chips for Xcode, you might need to toggle on and off "<strong>Open using Rosetta</strong>".</p><p>I really hope this helps you from losing your mind googling for an answer to this solution!</p><p>Thanks for reading!</p><img src="https://tprezioso.github.io//images/Screen-Shot-2021-09-17-at-7.35.52-PM-444x1024.png"/>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2021/2021-06-24-how-to-use-asyncimage-in-swiftui-3</guid><title>"How to Use AsyncImage in SwiftUI 3"</title><description></description><link>https://tprezioso.github.io/posts/2021/2021-06-24-how-to-use-asyncimage-in-swiftui-3</link><pubDate>Thu, 24 Jun 2021 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>How to Use AsyncImage in SwiftUI 3</h1><p>Recently Apple has announced <strong><a href="https://developer.apple.com/documentation/swiftui/asyncimage?changes=__5">AsyncImage</a></strong> at WWDC 2021. This makes loading images from a URL very easy in SwiftUI projects supporting iOS 15 and above. Let's take a look at an example below.</p><p>If we want to load an image from a URL, all we need to do is add the following line of code.</p><pre><code><span class="type">AsyncImage</span>(url: https://i1.<span class="property">wp</span>.<span class="property">com</span>/swifttom.<span class="property">com</span>/wp-content/uploads/<span class="number">2019</span>/<span class="number">10</span>/img_8186-<span class="number">2</span>.<span class="property">jpg</span>?resize=<span class="number">338</span>%2C452&amp;ssl=<span class="number">1</span>)
</code></pre><p>That's it! This is all the work we have to do to load an image from a URL! The only problem here is the URL image will most likely take up the whole screen because we didn't set the image modifiers. We also would want some sort of placeholder image while the URL image loads. No worries, <strong><a href="https://developer.apple.com/documentation/swiftui/asyncimage?changes=__5">AsyncImage</a></strong> has us covered.</p><p>By adding initializers to our <strong><a href="https://developer.apple.com/documentation/swiftui/asyncimage?changes=__5">AsyncImage</a></strong>, we can have a placeholder while the image is loading and style our image once is has loaded.</p><pre><code>             <span class="type">AsyncImage</span>(
                url:https://i1.<span class="property">wp</span>.<span class="property">com</span>/swifttom.<span class="property">com</span>/wp-content/uploads/<span class="number">2019</span>/<span class="number">10</span>/img_8186-<span class="number">2</span>.<span class="property">jpg</span>?resize=<span class="number">338</span>%2C452&amp;ssl=<span class="number">1</span>,
                content: { image <span class="keyword">in</span>
                    image.<span class="call">resizable</span>()
                         .<span class="call">scaledToFit</span>()
                         .<span class="call">frame</span>(maxWidth: <span class="number">100</span>, maxHeight: <span class="number">100</span>)
                },
                placeholder: {
                    <span class="type">ProgressView</span>()
                }
            )
</code></pre><p>In the example above we have added a <strong>content</strong> parameter to our <strong><a href="https://developer.apple.com/documentation/swiftui/asyncimage?changes=__5">AsyncImage</a></strong>. This allows us to set the image modifiers to give our image styling. We also added a <strong>placeholder</strong> parameter which allows us to show a view as a placeholder until our image has loaded. In the example above we are using a <strong><a href="https://developer.apple.com/documentation/swiftui/progressview/">ProgressView</a></strong> as our placeholder until the image loads.</p><p>I hope you find this useful in your next SwiftUI 3 projects! Happy coding!! üåÅüì∏ü§≥</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2021/2021-05-18-archs-unbound-variable-error-in-swiftui-project</guid><title>"ARCHS[@]: unbound variable" error in SwiftUI Project"</title><description></description><link>https://tprezioso.github.io/posts/2021/2021-05-18-archs-unbound-variable-error-in-swiftui-project</link><pubDate>Tue, 18 May 2021 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>"ARCHS[@]: unbound variable" error in SwiftUI Project</h1><p>Recently I ran into an error when trying to run a SwiftUI Project on my iPhone. I'm running this project on a <strong>M1 Macbook Pro</strong>. The error seemed to start happening when my project started using certain <strong>Cocoapods</strong>. The error reads "<strong>ARCHS[@]: unbound variable</strong>".</p><p>To fix this error all you need to do is navigate to the <strong>Project File</strong> <strong>&gt;</strong> <strong>Info</strong> <strong>&gt;</strong> <strong>Excluded Architecture</strong>. If in <strong>Excluded Architecture</strong> you see <strong>arm64</strong>, all you need to do is remove the <strong>arm64</strong> and reload your Xcode project.</p><img src="https://tprezioso.github.io//images/Screen-Shot-2021-05-18-at-1.06.06-PM-1024x303.png"/><p>Hope this quick post helps anyone struggling with this weird error in your SwiftUI project. If this doesn't help please check out this <a href="https://stackoverflow.com/questions/64474801/archs-unbound-variable-in-xcode-12">stack overflow post</a>.</p><p>Happy coding!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2021/2021-05-08-how-to-make-a-launch-screen-in-swiftui</guid><title>"How to Make a Launch Screen in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2021/2021-05-08-how-to-make-a-launch-screen-in-swiftui</link><pubDate>Sat, 8 May 2021 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>How to Make a Launch Screen in SwiftUI</h1><p>In this post we are going to look at how we can implement a launch screen in our SwiftUI project. In the past we would usually have to use a storyboard or XIB file to make our launch screens. In SwiftUI, we can now use the <strong>Info.plist</strong> to make our launch screen.</p><p>Let us get started by first navigating to our <strong>Info.plist</strong> file and towards the bottom we should see a <strong>"Launch Screen"</strong> area in our plist.</p><img src="https://tprezioso.github.io//images/Screen-Shot-2021-05-06-at-7.02.08-PM.png"/><p>If we click the little plus button next to where it says <strong>"Dictionary"</strong> we should see a list of options popup.</p><img src="https://tprezioso.github.io//images/Screen-Shot-2021-05-06-at-7.05.44-PM.png"/><ol><li><strong>Background color:</strong> Here we can set the color of the launch screens background</li><li><strong>Image name:</strong> Here we can set an image to our launch screen at the images size / resolution</li><li><strong>Image respects safe area insets:</strong> This is a bool where we can allow the image to respect or exceed the safe area of the screen</li><li><strong>Show navigation bar:</strong> This is a bool where we can display a mock up of a Navigation bar</li><li><strong>Show Tab bar:</strong> This is a bool where we can display a mock up of a Tab bar</li><li><strong>Show Toolbar:</strong> This is a bool where we can display a mock up of a tool bar</li></ol><p>In this example we are only going to add an image to our launch screen. To do this we will click on the <strong>"Image Name"</strong> option. This will add an image name property to our plist with a blank string. We will leave this blank for now but we will soon fill it in with our image name.</p><p>Next we will need to add an image to our <strong>Assets.xcassets</strong> file. Once we have dragged and dropped an image into our <strong>Assets.xcassets</strong> file, we will now copy the image name and paste it into the string area of <strong>"Launch Screen</strong>" "<strong>Image Name"</strong> back in our plist.</p><img src="https://tprezioso.github.io//images/Screen-Shot-2021-05-07-at-6.51.18-PM-1-1024x210.png"/><img src="https://tprezioso.github.io//images/Screen-Shot-2021-05-07-at-6.51.59-PM-1.png"/><p>As you can see in the images above we added an image named <strong>"144"</strong> to our projects assets file. We then set that image in our <strong>Info.plist</strong> to be our launch screen image (<em>Don't ever name an image with a number</em> ü§¢). Now if we go and run our app we should see a quick glimpse of our launch screen image before the app loads.</p><img src="https://tprezioso.github.io//images/Simulator-Screen-Shot-iPhone-12-Pro-2021-05-07-at-19.01.03-473x1024.png"/><p>That is all you need to make a launch screen in SwiftUI! This is just another example of how SwiftUI makes developers lives that much easier.</p><p>Hope this helps you on your next SwiftUI project!</p><p>Thanks for reading and Happy coding üöÄüì± üöÄüì±</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2021/2021-03-24-how-to-add-external-libraries-to-a-swiftui-project-using-swift-package-manager</guid><title>"How to Add External Libraries to a SwiftUI Project Using Swift Package Manager"</title><description></description><link>https://tprezioso.github.io/posts/2021/2021-03-24-how-to-add-external-libraries-to-a-swiftui-project-using-swift-package-manager</link><pubDate>Wed, 24 Mar 2021 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>How to Add External Libraries to a SwiftUI Project Using Swift Package</h1><p>In this post we are going to look at how we can add a Swift package to our SwiftUI Project. Let's start by going to the <a href="http://swiftpackageindex.com">Swift Package Index</a> website and searching through the libraries. For this post we are going to use the <a href="https://swiftpackageindex.com/AppPear/ChartView">SwiftUICharts</a> package to add to our project.</p><img src="https://tprezioso.github.io//images/Screen-Shot-2021-03-19-at-6.42.32-PM.png"/><p><strong>SwiftUICharts</strong> is an amazing library that makes it super easy to get beautifully animated charts into your SwiftUI project.</p><p>Now that we have picked the library we want to add to our project, we now need to click on the copy button under the <strong>SwiftUICharts</strong> title. This copies the link to <strong>SwiftUICharts</strong> <strong>GitHub</strong> so that we can download the package to our project.</p><p>Now that we have our link to <strong>SwiftUICharts</strong> repo, we will need to go to our Xcode project and click on <strong>File</strong> <strong>&gt;</strong> <strong>Swift</strong> <strong>Packages</strong> <strong>&gt; Add Package Dependency</strong> and then paste in the repo's url:¬†<code>**https://github.com/AppPear/ChartView**</code></p><img src="https://tprezioso.github.io//images/Screen-Shot-2021-03-22-at-2.15.39-PM-1024x622.png"/><p>Once you click on the next button, you will then have to choose what version, branch or commit from the package you would like to use.</p><img src="https://tprezioso.github.io//images/Screen-Shot-2021-03-22-at-2.17.25-PM-1024x612.png"/><p>Here we will not mess with any of the options and just click on the next button. This will now download the package into your Xcode project. Once downloaded, we will make sure our package is selected and click on the finish button.</p><p>Now we should see that our package has been successfully added to our project.</p><img src="https://tprezioso.github.io//images/Screen-Shot-2021-03-22-at-2.21.29-PM-1024x327.png"/><p>Thats all there is too it!</p><p>From here we can import the <strong>SwiftUICharts</strong> library into a file and start using all the amazing charts and animations <strong>SwiftUICharts</strong> has to offer.</p><p>If you would like a deeper dive into <strong>Swift Package Manager</strong> I would recommend checking out this <a href="https://medium.com/xcblog/apple-swift-package-manager-a-deep-dive-ebe6909a5284">great article</a> by @Shashikant86</p><p>Thanks for reading and happy coding!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2021/2021-03-10-how-to-make-a-custom-hud-view-in-swiftui</guid><title>"How to Make a Custom HUD View in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2021/2021-03-10-how-to-make-a-custom-hud-view-in-swiftui</link><pubDate>Wed, 10 Mar 2021 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>How to Make a Custom HUD View in SwiftUI</h1><p>In this post we are going to make a custom <strong>HUD</strong> view with a timer. The timer will dismiss our HUD view after about a second. Our <strong>HUD</strong> view will be similar to the pop up view we see on our screen when we put our phone into silent mode.</p><img src="https://tprezioso.github.io//images/silentMode.jpg"/><p>Let's jump right in by creating a new SwiftUI file and naming it <strong>HUDView</strong>. Next we are going to copy the code below into our <strong>HUDView.swift</strong> file.</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> HUDView&lt;Content: <span class="type">View</span>&gt;: <span class="type">View</span> {
    <span class="keyword">var</span> content: <span class="type">Content</span>
    <span class="keyword">@ViewBuilder var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        content
            .<span class="call">padding</span>(.<span class="dotAccess">horizontal</span>, <span class="number">10</span>)
            .<span class="call">padding</span>(<span class="number">10</span>)
            .<span class="call">background</span>(
                <span class="type">Capsule</span>()
                    .<span class="call">foregroundColor</span>(<span class="type">Color</span>.<span class="property">white</span>)
                    .<span class="call">shadow</span>(color: <span class="type">Color</span>(.<span class="dotAccess">black</span>).<span class="call">opacity</span>(<span class="number">0.10</span>), radius: <span class="number">10</span>, x: <span class="number">0</span>, y: <span class="number">5</span>)
            )
    }
}

<span class="keyword">struct</span> HUD_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">HUDView</span>(content: <span class="type">Text</span>(<span class="string">"HI"</span>))
    }
}
</code></pre><p>Above we created a <strong>HUD</strong> view that takes in a view as a variable and then presents that view when the <strong>HUD</strong> appears. We also stylized our <strong>HUD</strong> to look like the pill shaped silent mode view in the image above. Now that we have created our <strong>HUD</strong> lets go add it to our <strong>ContentView.swift</strong> file.</p><p>In our <strong>ContentView</strong> file we will replace the boilerplate code with the code below.</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">HUDView</span>(content: <span class="type">Text</span>(<span class="string">"Hello, World!"</span>))
    }
}
</code></pre><img src="https://tprezioso.github.io//images/Simulator-Screen-Shot-iPod-touch-7th-generation-2021-03-08-at-14.10.56-577x1024.png"/><p>In our preview screen we should see a pill shaped view with a text view saying "Hello World!".</p><p>Next we will need to move our <strong>HUD</strong> view from the middle of our view to the top of our view. Let's take a look at the example below to see how we can setup our <strong>HUD</strong> view.</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">ZStack</span>(alignment: .<span class="dotAccess">top</span>) {
            <span class="type">NavigationView</span> {
                <span class="type">Button</span>(<span class="string">"Save"</span>) {
                    
                }
                .<span class="call">navigationTitle</span>(<span class="string">"Home"</span>)
            }
            <span class="type">HUDView</span>(content: <span class="type">Text</span>(<span class="string">"Save"</span>))
        }
    }
}
</code></pre><img src="https://tprezioso.github.io//images/Simulator-Screen-Shot-iPod-touch-7th-generation-2021-03-08-at-14.35.20-577x1024.png"/><p>As you can see in the code above we added a <strong>ZStack</strong> to keep our <strong>HUD</strong> view aligned to the top and above the content on screen. Next we added a save button which will show our <strong>HUD</strong> view when we tap on the button. Lastly we added a <strong>NavigationView</strong> so we can have a navigation title on our screen for some style points.</p><p>Now when our save button is tapped we will want to present our <strong>HUDView</strong>. Then after 1.5 seconds we will have our <strong>HUD</strong> dismiss itself. To do this let us add the code below to our <strong>ContentView</strong> file.</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">@State private var</span> showHUD = <span class="keyword">false
    var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">ZStack</span>(alignment: .<span class="dotAccess">top</span>) {
            <span class="type">NavigationView</span> {
                <span class="type">Button</span>(<span class="string">"Save"</span>) {
                    <span class="call">withAnimation</span> {
                        <span class="keyword">self</span>.<span class="property">showHUD</span>.<span class="call">toggle</span>()
                        <span class="call">dismissHUD</span>()
                    }
                }
                .<span class="call">navigationTitle</span>(<span class="string">"Home"</span>)
            }
            
            <span class="type">HUDView</span>(content: <span class="type">Text</span>(<span class="string">"Save"</span>))
                .<span class="call">offset</span>(y: showHUD ? <span class="number">0</span> : -<span class="number">100</span>)
                .<span class="call">animation</span>(.<span class="call">spring</span>())
        }
    }

    <span class="keyword">func</span> dismissHUD() {
        <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">asyncAfter</span>(deadline: .<span class="call">now</span>() + <span class="number">1.5</span>) {
            <span class="keyword">self</span>.<span class="property">showHUD</span> = <span class="keyword">false</span>
        }
    }

}
</code></pre><p>Above we added a <strong>@State</strong> property to track when we will show and hide the <strong>HUD</strong> view. Then we added the <strong>dismissHUD()</strong> function so that we can dismiss the <strong>HUD</strong> view after 1.5 seconds(feel free to change the time to dismiss to whatever you like best). Lastly we added an <strong>.offset</strong> and <strong>.animation(.spring())</strong> modifier to our <strong>HUD</strong> view. We added the <strong>.offset</strong> modifier so we can hide the <strong>HUD</strong> view offscreen when not being shown. We also added a spring animation to give our <strong>HUD</strong> some bounce when entering the view from off screen. Now when we run our app and press our save button, we should see our <strong>HUD</strong> appear and then disappear after 1.5 seconds.</p><p>https://videopress.com/v/GThOyjdD?controls=false&amp;loop=true&amp;preloadContent=metadata</p><p>Thanks for reading! Hope this helps you in your next SwiftUI project.</p><p>Happy Coding!</p><img src="https://tprezioso.github.io//images/LhZn.gif" alt="Iron man GIF - Find on GIFER"/>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2021/2021-02-22-picker-view-styles-in-swiftui</guid><title>"Picker View Styles in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2021/2021-02-22-picker-view-styles-in-swiftui</link><pubDate>Mon, 22 Feb 2021 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>Picker View Styles in SwiftUI</h1><p>In this post we are going to take a look at the different ways we can style a picker view in our SwiftUI project. Let's first setup a simple picker view like in the example below.</p><pre><code>     <span class="keyword">var</span> arrayOfNames = [<span class="string">"Tom"</span>, <span class="string">"Nick"</span>, <span class="string">"Tony"</span>, <span class="string">"Dylan"</span>]
    <span class="keyword">@State private var</span> selectedIndex = <span class="number">0</span>
    
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">Picker</span>(<span class="string">"Names"</span>, selection: <span class="property">$selectedIndex</span>) {
            <span class="type">ForEach</span>(<span class="number">0</span> ..&lt; arrayOfNames.<span class="property">count</span>) {
                <span class="type">Text</span>(<span class="keyword">self</span>.<span class="property">arrayOfNames</span>[$0])
            }
        }
    }
}
</code></pre><img src="https://tprezioso.github.io//images/Simulator-Screen-Shot-iPod-touch-7th-generation-2021-02-19-at-17.19.09-577x1024.png"/><p>Above we created a basic picker view with four names to choose from. Now let us change the style of our picker to be included in a <strong>Form</strong>.</p><pre><code>     <span class="keyword">var</span> arrayOfNames = [<span class="string">"Tom"</span>, <span class="string">"Nick"</span>, <span class="string">"Tony"</span>, <span class="string">"Dylan"</span>]
    <span class="keyword">@State private var</span> selectedIndex = <span class="number">0</span>
    
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">NavigationView</span> {
            <span class="type">Form</span> {
                <span class="type">Picker</span>(<span class="string">"Names"</span>, selection: <span class="property">$selectedIndex</span>) {
                    <span class="type">ForEach</span>(<span class="number">0</span> ..&lt; arrayOfNames.<span class="property">count</span>) {
                        <span class="type">Text</span>(<span class="keyword">self</span>.<span class="property">arrayOfNames</span>[$0])
                    }
                }
            }
        }
    }
}
</code></pre><ul><li><img src="https://tprezioso.github.io//images/Simulator-Screen-Shot-iPhone-12-2021-02-21-at-11.05.49-1-473x1024.png"/><ul></ul></li></ul><ul><li><img src="https://tprezioso.github.io//images/Simulator-Screen-Shot-iPhone-12-2021-02-21-at-11.05.54-1-473x1024.png"/><ul></ul></li></ul><p>In the example above is wrapped our code in a <strong>NavigationView</strong> and a <strong>Form</strong>. This changes our picker view style so that it segues us to another view to make our selection. This is great for a picker that has many options to choose from. But let's say we didn't want to segue to another view to see our options.</p><p>Let's see how we can implement a segmented picker view style.</p><pre><code>     <span class="keyword">var</span> arrayOfNames = [<span class="string">"Tom"</span>, <span class="string">"Nick"</span>, <span class="string">"Tony"</span>, <span class="string">"Dylan"</span>]
    <span class="keyword">@State private var</span> selectedIndex = <span class="number">0</span>
    
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">NavigationView</span> {
            <span class="type">Form</span> {
                <span class="type">Picker</span>(<span class="string">"Names"</span>, selection: <span class="property">$selectedIndex</span>) {
                    <span class="type">ForEach</span>(<span class="number">0</span> ..&lt; arrayOfNames.<span class="property">count</span>) {
                        <span class="type">Text</span>(<span class="keyword">self</span>.<span class="property">arrayOfNames</span>[$0])
                    }
                }.<span class="call">pickerStyle</span>(<span class="type">SegmentedPickerStyle</span>())
            }
        }
    }
</code></pre><img src="https://tprezioso.github.io//images/Simulator-Screen-Shot-iPhone-12-2021-02-21-at-11.14.46-473x1024.png"/><p>By just adding <strong>.pickerStyle(SegmentedPickerStyle())</strong> to our picker view, SwiftUI gives us a segmented style picker view with minimal change to our code.</p><p>Let's say we don't want either of these styles. What if we wanted a picker view like we originally had in our first example. We can easily do this by switching our picker style to <strong>.pickerStyle(</strong>WheelPickerStyle<strong>())</strong>.</p><img src="https://tprezioso.github.io//images/Simulator-Screen-Shot-iPhone-12-2021-02-21-at-11.20.45-473x1024.png"/><p>I hope this helps you in your next SwiftUI Project.</p><p>Thanks for reading and happy coding! ‚õè‚õè‚õè</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2021/2021-02-16-no-such-module-found-m1-macbook-pro-solution</guid><title>"No Such Module Found (M1 Macbook Pro Solution)"</title><description></description><link>https://tprezioso.github.io/posts/2021/2021-02-16-no-such-module-found-m1-macbook-pro-solution</link><pubDate>Tue, 16 Feb 2021 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>No Such Module Found (M1 Macbook Pro Solution)</h1><p>Recently I have been working on a new project with my new M1 Macbook Pro. In this project I needed to use third party libraries such as <strong>FBSDKCoreKit</strong> (Facebook) so the user could sign in with their Facebook account. The problem I ran into was that no matter what I did the <a href="https://cocoapods.org/">Cocoapods</a> I loaded into my project would not run. Xcode would give me error messages such as "<strong>No such module found</strong>" or "<strong>module 'FBSDKCoreKit' not found</strong>".</p><p>After hours of googling and looking at Github issues on the topic, I found the solution. If you are running into this problem on a M1 Mac you need to open Xcode using <strong>Rosetta</strong>. What is <strong>Rosetta</strong>? Without getting too technical <strong>Rosetta</strong> allows the new M1 Mac's to run x86 architecture apps. For a deeper dive into Rosetta check out the link <a href="https://www.computerworld.com/article/3597949/everything-you-need-to-know-about-rosetta-2-on-apple-silicon-macs.html">here</a>. If you need to install Rosetta 2 on your M1 Mac click on this link <a href="https://osxdaily.com/2020/12/04/how-install-rosetta-2-apple-silicon-mac/">here</a> and follow the tutorial.</p><p>Now to fix this issue we need to go into our <strong>Finder</strong> &gt; <strong>Applications</strong> <strong>&gt;</strong> and right click (command ‚åò + click) on Xcode. Then we need to select "<strong>Get Info</strong>"</p><img src="https://tprezioso.github.io//images/Screen-Shot-2021-02-16-at-9.21.05-AM.png"/><p>Once we have the <strong>"Get Info</strong>" window opened, we then need to click on "<strong>Open using Rosetta</strong>"</p><img src="https://tprezioso.github.io//images/Screen-Shot-2021-02-16-at-9.23.02-AM.png"/><p>Now if we relaunch our Xcode and build our project we shouldn't see anymore errors like "<strong>Module not Found</strong>". I hope this helps save you some time and headaches.</p><p>Thanks for reading. Happy Coding!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2021/2021-02-15-how-to-add-an-appdelegate-to-a-swiftui-project</guid><title>"How to Add an AppDelegate to a SwiftUI Project"</title><description></description><link>https://tprezioso.github.io/posts/2021/2021-02-15-how-to-add-an-appdelegate-to-a-swiftui-project</link><pubDate>Mon, 15 Feb 2021 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>How to Add an AppDelegate to a SwiftUI Project</h1><p>When you create a new SwiftUI project, you will see that we no longer have the <strong>AppDelegate.swift</strong> file. This doesn't mean we don't need or use the <strong>AppDelegate</strong> file anymore. If we want to implement something like push notifications we will need to use an <strong>AppDelegate</strong> in our SwiftUI app. Let's take a look at how we can add an <strong>AppDelegate</strong> file to our SwiftUI project.</p><p>First we will need to create a new swift file and name it <strong>AppDelegate</strong>. Now inside of our new <strong>AppDelegate</strong> file we will need to copy and paste the code below (Feel free to add any <strong>AppDelegate</strong> functions you need for your project).</p><pre><code><span class="keyword">import</span> UIKit

<span class="keyword">class</span> AppDelegate: <span class="type">UIResponder</span>, <span class="type">UIApplicationDelegate</span> {
    <span class="keyword">func</span> application(<span class="keyword">_</span> application: <span class="type">UIApplication</span>, didFinishLaunchingWithOptions launchOptions: [<span class="type">UIApplication</span>.<span class="type">LaunchOptionsKey</span> : <span class="type">Any</span>]? = <span class="keyword">nil</span>) -&gt; <span class="type">Bool</span> {

        <span class="comment">// Your Code Here!</span>
        <span class="keyword">return true</span>
    }
}
</code></pre><p>Now that we have our <strong>AppDelegate</strong> created, we will need to tell our app to use the <strong>AppDelegate.swift</strong> file. Let us navigate over to the App file in our project. This file is named after your project with <strong>"App</strong>" at the end. In this example my file is named <strong>AppDelegateBlogProjectApp.swift</strong> (Not the best name in the world ü§£).</p><p>In this file we will create and wrap our AppDelegate property in the <strong>UIApplicationDelegateAdaptor</strong>¬†property wrapper. This tells SwiftUI we want to use the <strong>AppDelegate</strong> file we just created.</p><pre><code><span class="keyword">@main
struct</span> AppDelegateBlogProject: <span class="type">App</span> {
    <span class="keyword">@UIApplicationDelegateAdaptor</span>(<span class="type">AppDelegate</span>.<span class="keyword">self</span>) <span class="keyword">var</span> appDelegate

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> {
        <span class="type">WindowGroup</span> {
            <span class="type">ContentView</span>()
        }
    }
}
</code></pre><p>That is all we need to make an <strong>AppDelegate</strong> in a SwiftUI project!</p><p>Thanks for reading!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2021/2021-02-08-appstorage-in-swiftui</guid><title>"@Appstorage in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2021/2021-02-08-appstorage-in-swiftui</link><pubDate>Mon, 8 Feb 2021 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>@Appstorage in SwiftUI</h1><p><strong><a href="https://developer.apple.com/documentation/swiftui/appstorage">Appstorage</a></strong> is a property wrapper for getting stored values from <strong><a href="https://developer.apple.com/documentation/foundation/userdefaults">UserDefaults</a></strong> in SwiftUI. We use <strong>@Appstorage</strong> too reload our body view property whenever the value changes of our <strong>UserDefaults</strong>. This keeps our view up to date with the data that we have stored. Let's take a look at an example on how we can use <strong>@Appstorage</strong> in our SwiftUI project.</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">@AppStorage</span>(<span class="string">"isCookieTime"</span>) <span class="keyword">var</span> isCookieTime = <span class="keyword">false
    
    var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
            <span class="type">Toggle</span>(<span class="string">"Cookie time"</span>, isOn: <span class="property">$isCookieTime</span>)
        .<span class="call">padding</span>()
    }
}
</code></pre><p>In the example above we have a Toggle view for "Cookie time" üç™. We use our <strong>@AppStorage</strong> property to watch our <strong>isCookieTime</strong> variable. If the value changes it is then stored in our <strong>UserDefaults</strong>. Now our toggle will show the stored value depending on the <strong>@AppStorage</strong>.</p><p>A example of where I use <strong>@AppStorage</strong> is for storing things like a users settings options in a settings screen of an app. I hope this helps explain how to use <strong>@AppStorage</strong> in SwiftUI.</p><p>Thanks for reading and happy coding.</p><img src="https://tprezioso.github.io//images/storageFull.jpg"/>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2021/2021-01-29-how-to-make-a-code-snippet-in-xcode</guid><title>"How to Make a Code Snippet in Xcode"</title><description></description><link>https://tprezioso.github.io/posts/2021/2021-01-29-how-to-make-a-code-snippet-in-xcode</link><pubDate>Fri, 29 Jan 2021 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>How to Make a Code Snippet in Xcode</h1><p>Code snippets are shortcuts to blocks of boilerplate code that we use most often when programming. Xcode allows us to add custom snippets to the many pre-existing snippets that Apple provides. Let's see how we can make a code snippet out of the following code below.</p><pre><code><span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
                    
                }
</code></pre><p>You might be familiar with the example code above. This block of code is used to make sure things like network calls are made on the main thread and not on a background thread. Let's make a code snippet of this so we don't have to type the whole thing out every time we want to use it.</p><p>If we highlight the code and then right click (‚åò + click) you will see an option to "Create Code Snippet".</p><img src="https://tprezioso.github.io//images/Screen-Shot-2021-01-29-at-5.53.45-PM.png"/><p>Once we click on "Create Code Snippet" a window will popup and prompt us to customize our code snippet.</p><img src="https://tprezioso.github.io//images/Screen-Shot-2021-01-29-at-5.55.10-PM.png"/><p>First we will name our snippet "Dispatch Main Queue" (Feel free to name it whatever you want üòÑ). Now we will leave everything else the same except the "Completion" section. In the "Completion" textfield we will type in "dpm".</p><img src="https://tprezioso.github.io//images/Screen-Shot-2021-01-29-at-5.59.41-PM.png"/><p>What this does is every time we type "dpm" Xcode will prompt us in the autocompletion to see if we want to use our code snippet! So from now on anytime we want to put something on the main thread all we have to do is type "dpm" and we get our code snippet we just created.</p><img src="https://tprezioso.github.io//images/Screen-Shot-2021-01-29-at-6.05.13-PM-1.png"/><img src="https://tprezioso.github.io//images/Screen-Shot-2021-01-29-at-6.05.30-PM-1.png"/><p>Just like that we have made a code snippet and saved ourselves time by never having to type out all that code ever again! Feel free to make code snippets of any block of code your tired of typing out! Embrace your laziness!</p><p>Thanks for reading and I hope this helps your coding productivity.</p><p>Happy coding!</p><img src="https://64.media.tumblr.com/26460fbabb524c6906212d60cb0bfe2e/tumblr_inline_pae21mGEP91s6q7r3_500.gifv" alt="Texas Tribune Nerds - What I Learned at The Texas Tribune"/>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2021/2021-01-18-how-to-make-a-tab-bar-view-in-swiftui</guid><title>"How to Make a Tab Bar View in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2021/2021-01-18-how-to-make-a-tab-bar-view-in-swiftui</link><pubDate>Mon, 18 Jan 2021 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>How to Make a Tab Bar View in SwiftUI</h1><p>In this post we are going to take a look at how we can add a tab bar view to our SwiftUI app. Tab bar views are used to display a view when the tab item is selected. For this example we will simply have two tab views that will show a text view with a different background color. Let's start by creating our example views that we will assign to our tab bar.</p><pre><code><span class="keyword">import</span> SwiftUI
<span class="keyword">struct</span> FirstView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">ZStack</span> {
            <span class="type">Color</span>(.<span class="dotAccess">green</span>)
            <span class="type">Text</span>(<span class="string">"First View"</span>)
                .<span class="call">font</span>(.<span class="dotAccess">title</span>)
        }.<span class="call">ignoresSafeArea</span>()
    }
}
</code></pre><pre><code><span class="keyword">struct</span> SecondView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">ZStack</span> {
            <span class="type">Color</span>(.<span class="dotAccess">blue</span>)
            <span class="type">Text</span>(<span class="string">"Second View"</span>)
                .<span class="call">font</span>(.<span class="dotAccess">title</span>)
                .<span class="call">foregroundColor</span>(.<span class="dotAccess">white</span>)
        }.<span class="call">ignoresSafeArea</span>()
    }
}
</code></pre><p>As you can see we have created two views with just a text view and a color for the background. Now that we have our views setup we can go to our <strong>ContentView.swift</strong> file and make our tab bar view.</p><pre><code><span class="keyword">import</span> SwiftUI
<span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">TabView</span> {
            <span class="type">FirstView</span>()
                .<span class="call">tabItem</span> {
                    <span class="type">Image</span>(systemName: <span class="string">"1.circle.fill"</span>)
                    <span class="type">Text</span>(<span class="string">"First View"</span>)
                }
        
            <span class="type">SecondView</span>()
                .<span class="call">tabItem</span> {
                    <span class="type">Image</span>(systemName: <span class="string">"2.circle.fill"</span>)
                    <span class="type">Text</span>(<span class="string">"Second View"</span>)
                }
        }
    }
}
</code></pre><p>As you can see in the example above all we needed to do was make a <strong>TabView</strong> and initialize our two views as a .<strong>tabItem</strong>. Inside of our .<strong>tabItem</strong> we added an image and the title to be displayed on our tab. Now if we run our application we should see our app look like the images below.</p><img src="https://i0.wp.com/swifttom.com/wp-content/uploads/2021/01/Simulator-Screen-Shot-iPhone-12-Pro-2021-01-18-at-16.02.47.png?fit=473%2C1024&ssl=1"/><img src="https://i0.wp.com/swifttom.com/wp-content/uploads/2021/01/Simulator-Screen-Shot-iPhone-12-Pro-2021-01-18-at-16.02.50.png?fit=473%2C1024&ssl=1"/><p>I hope this helps you on your next SwiftUI project.</p><p>Thanks for reading and happy coding!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2021/2021-01-11-how-to-fetch-json-data-from-apis-in-swiftui</guid><title>"How to Fetch JSON Data from APIs in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2021/2021-01-11-how-to-fetch-json-data-from-apis-in-swiftui</link><pubDate>Mon, 11 Jan 2021 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>How to Fetch JSON Data from APIs in SwiftUI</h1><p>In this post we are going to take a look at how we can get JSON data from an API and show it in a list view in SwiftUI. Let's jump right in a get started by creating a new SwiftUI project.</p><p>In this project we are going to be using the <a href="https://jsonplaceholder.typicode.com/">JSONPlaceholder</a> API. <a href="https://jsonplaceholder.typicode.com/">JSONPlaceholder</a> is a free to use fake <strong>REST API</strong> for testing and prototyping.</p><p>We will be fetching our data from the <strong><em>https://jsonplaceholder.typicode.com/posts/1/comments</em></strong> URL.</p><p>Now in our Xcode project we will create a model file and name it <strong>Comments</strong>. This will be our model for the data we are going to want to show in our list view.</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> Comments: <span class="type">Codable</span>, <span class="type">Identifiable</span> {
    <span class="keyword">let</span> id = <span class="type">UUID</span>()
    <span class="keyword">let</span> name: <span class="type">String</span>
    <span class="keyword">let</span> email: <span class="type">String</span>
    <span class="keyword">let</span> body: <span class="type">String</span>
    
}
</code></pre><p>In the code above we made a simple struct that conforms to the <a href="https://developer.apple.com/documentation/swift/codable">Codable</a> and <a href="https://developer.apple.com/documentation/swift/identifiable">Identifiable</a> protocols. <a href="https://developer.apple.com/documentation/swift/codable">Codable</a> is used for decoding and encoding the JSON data we get from our API call. <a href="https://developer.apple.com/documentation/swift/identifiable">Identifiable</a> is used to help us make a unique identifier for our <strong>Comments</strong> object so our app can keep track of it. In our example it helps us to keep track of our comments and display them in the right order for our list view. We also have added the <strong>name</strong>, <strong>email</strong>, and <strong>body</strong> properties that will be set to the JSON data we get back from our API call.</p><p>Next we will add a new file where we will create the call to our API to get our JSON data. Let's start by creating a new file and naming it <strong>commentViewModel</strong>. Then we will add the following code to our <strong>commentViewModel</strong> file.</p><pre><code><span class="keyword">import</span> Foundation

<span class="keyword">class</span> apiCall {
    <span class="keyword">func</span> getUserComments(completion:<span class="keyword">@escaping</span> ([<span class="type">Comments</span>]) -&gt; ()) {
        <span class="keyword">guard let</span> url = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/posts/1/comments"</span>) <span class="keyword">else</span> { <span class="keyword">return</span> }
        
        <span class="type">URLSession</span>.<span class="property">shared</span>.<span class="call">dataTask</span>(with: url) { (data, <span class="keyword">_</span>, <span class="keyword">_</span>) <span class="keyword">in
            let</span> comments = <span class="keyword">try</span>! <span class="type">JSONDecoder</span>().<span class="call">decode</span>([<span class="type">Comments</span>].<span class="keyword">self</span>, from: data!)
            <span class="call">print</span>(comments)
            
            <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
                <span class="call">completion</span>(comments)
            }
        }
        .<span class="call">resume</span>()
    }
}
</code></pre><p>Above all we did was create a class called <strong>apiCall</strong> and added a function called <strong>getUserComments()</strong>. In our <strong>getUserComments()</strong> function we first make a <strong>guard let</strong> statement on our <strong>url</strong> variable. This is to check to make sure we have a valid URL otherwise the function will stop there and not execute the rest of the code.</p><p>Next we use <a href="https://developer.apple.com/documentation/foundation/urlsession">URLSession</a> to make our call to get the data from the URL. Inside of our <a href="https://developer.apple.com/documentation/foundation/urlsession">URLSession</a> closure we create a new variable called <strong>comments</strong> and we assign the decoded JSON to our variable. Then we use <strong><a href="https://developer.apple.com/documentation/dispatch/dispatchqueue">DispatchQueue</a></strong> to make sure we are running this API call on the main thread and not a background thread of our app. On completion of retrieving our data we then assigns the data to our comments variable. Lastly we can't forget the <strong>.resume()</strong> function at the end of your <a href="https://developer.apple.com/documentation/foundation/urlsession">URLSession</a> curly brace. If you forget this the function will never run the API call to the URL.</p><p>Now that we have our view model setup lets go into <strong>ContentView</strong> file and add the following code to our file.</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="comment">//1.</span>
    <span class="keyword">@State var</span> comments = [<span class="type">Comments</span>]()
    
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">NavigationView</span> {
            <span class="comment">//3.</span>
            <span class="type">List</span>(comments) { comment <span class="keyword">in</span>
                <span class="type">VStack</span>(alignment: .<span class="dotAccess">leading</span>) {
                    <span class="type">Text</span>(comment.<span class="property">name</span>)
                        .<span class="call">font</span>(.<span class="dotAccess">title</span>)
                        .<span class="call">fontWeight</span>(.<span class="dotAccess">bold</span>)
                    <span class="type">Text</span>(comment.<span class="property">email</span>)
                        .<span class="call">font</span>(.<span class="dotAccess">subheadline</span>)
                        .<span class="call">fontWeight</span>(.<span class="dotAccess">bold</span>)
                    <span class="type">Text</span>(comment.<span class="property">body</span>)
                        .<span class="call">font</span>(.<span class="dotAccess">body</span>)
                }
                
            }
            <span class="comment">//2.</span>
            .<span class="call">onAppear</span>() {
                <span class="call">apiCall</span>().<span class="call">getUserComments</span> { (comments) <span class="keyword">in
                    self</span>.<span class="property">comments</span> = comments
                }
            }.<span class="call">navigationTitle</span>(<span class="string">"Comments"</span>)
        }
    }
}
</code></pre><ol><li>First we created a <strong>@State</strong> variable that takes in an array of our <strong>Comments</strong> model.</li><li>Next we added the <strong>.<a href="https://developer.apple.com/documentation/swiftui/text/onappear(perform:)">onAppear</a>()</strong> function. This is were we make our call to our API to get our data and then set it to the <strong>comments</strong> variable we just created.</li><li>Then in our list view we pass in the data that we have in our <strong>Comments</strong> array</li></ol><p>Now we can go and run our app. We should see something like the image below.</p><img src="https://swifttom.com/wp-content/uploads/2021/01/simulator-screen-shot-iphone-12-pro-2021-01-08-at-16.39.36.png?w=473"/><p>Thats all we need to fetch and show JSON data in SwiftUI. Thanks for reading!</p><p>Happy Coding!</p><img src="https://tprezioso.github.io//images/giphy.gif%3Fcid=ecf05e47eve0t94gcjgizod66y2n5j54arndqtk30lp9cibk&rid=giphy.gif" alt="data numbers GIF"/>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2021/2021-01-03-how-to-make-a-phone-call-using-swiftui</guid><title>"How to Make a Phone Call using SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2021/2021-01-03-how-to-make-a-phone-call-using-swiftui</link><pubDate>Sun, 3 Jan 2021 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>How to Make a Phone Call using SwiftUI</h1><p>Making a phone call from a SwiftUI app is easy and only takes a few lines of code to implement. All we need to do is setup a button that will open the phone app and make a phone call with a phone number we pass in.</p><p>Let's look at some code below to see what we need to implement this.</p><pre><code>

<span class="keyword">struct</span> ContentView: <span class="type">View</span> {

    <span class="keyword">var</span> phoneNumber = <span class="string">"718-555-5555"</span>

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span> {
            <span class="type">Button</span>(action: {
                <span class="keyword">let</span> phone = <span class="string">"tel://"</span>
                <span class="keyword">let</span> phoneNumberformatted = phone + phoneNumber
                <span class="keyword">guard let</span> url = <span class="type">URL</span>(string: phoneNumberformatted) <span class="keyword">else</span> { <span class="keyword">return</span> }
                <span class="type">UIApplication</span>.<span class="property">shared</span>.<span class="call">open</span>(url)
               }) {
               <span class="type">Text</span>(phoneNumber)
                .<span class="call">foregroundColor</span>(.<span class="dotAccess">blue</span>)
            }
        }
    }
}
</code></pre><p>In the example above we first create a string variable with the phone number we would like to use. Next we create a button and within the action of our button we format the phone number to our URL. The "<strong>tel://</strong>" is the url needed to tell our device to open the phone app and make a call. (<em>We can use the same code above to open other apps on our device. For example if we wanted to open the mail app we just need to replace the url with <strong>messages://</strong> instead of **tel://</em>*_)</p><p>Next we have a <strong>guard let</strong> statement to check to see if we have a formatted phone number. Then we use <strong>UIApplication</strong> to open the phone app and make a call using the url with the phone number we passed in. Lastly we set our button label to show the phone number we want to call.</p><p>(<em>Side note: We will need to run this on a device to test because the simulator can not make phone calls.</em>)</p><p>That is all that we need to make a phone call from our SwiftUI app. Hope this helps you on your next SwiftUI project!</p><p>Thanks for reading!</p><p>‚òéÔ∏èüì±ü§≥Happy coding ‚òéÔ∏èüì±ü§≥</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-12-23-whats-the-difference-between-observedobject-and-stateobject</guid><title>"What‚Äôs the Difference between @ObservedObject and @StateObject"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-12-23-whats-the-difference-between-observedobject-and-stateobject</link><pubDate>Wed, 23 Dec 2020 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>What‚Äôs the Difference between @ObservedObject and @StateObject</h1><p><strong>@StateObject</strong> and <strong>@ObservedObject</strong> are very similar in that they both keep track of an objects state. The difference is <strong>@</strong>StateObject<strong></strong> is owned by the view it was created in where as <strong>@ObservedObject</strong> is owned by another view.</p><p>An example of when to use <strong>@ObservedObject</strong> is to keep track of external classes so the view can be updated when a change occurs. We would want to use an <strong>@ObservedObject</strong> for something like fetching new data from an API or a database.</p><p>We want to use <strong>@StateObject</strong> when we want the view to keep track of its own objects state. A example of how we would use <strong>@StateObject</strong> is if we had something like a number counter in a view and we wanted to keep track of the count as the numbers changed.</p><p>I hope this helps you better understand the difference between when to use <strong>@ObservedObject</strong> and <strong>@StateObject</strong>.</p><p>For a deeper dive into <strong>@StateObject</strong> vs <strong>@ObservedObject</strong> checkout these great articles by <a href="https://www.donnywals.com/whats-the-difference-between-stateobject-and-observedobject/">Donny Wals</a> and <a href="https://swapnanildhol.medium.com/stateobject-vs-observedobject-in-swiftui-40499592853">Swapnanil Dhol</a>.</p><p>Thanks for reading and happy coding üë®üèª‚Äçüíªüë®üèª‚Äçüíªüë®üèª‚Äçüíª</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-12-11-how-to-use-link-to-open-webpages-in-swiftui</guid><title>"How to Use Link to Open Webpages in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-12-11-how-to-use-link-to-open-webpages-in-swiftui</link><pubDate>Fri, 11 Dec 2020 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>How to Use Link to Open Webpages in SwiftUI</h1><p>SwiftUI makes opening a URL with your default web browser super easy with the <strong>Link</strong> view. All you need to do is give it a title and a destination URL. Let us take a look at the example below.</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">Link</span>(<span class="string">"Swift Tom!"</span>, destination: <span class="type">URL</span>(string: <span class="string">"https://www.swifttom.com/"</span>)!)
        
    }
}
</code></pre><ul><li><img src="https://swifttom.com/wp-content/uploads/2020/12/simulator-screen-shot-iphone-12-2020-12-11-at-17.05.00-1.png?w=473"/><ul></ul></li></ul><ul><li><img src="https://swifttom.com/wp-content/uploads/2020/12/simulator-screen-shot-iphone-12-2020-12-11-at-17.05.05-1.png?w=473"/><ul></ul></li></ul><p>As you can see in our example we are added a title of "Swift Tom!" and our destination URL swifttom.com. If we go and run this code in our simulator we will see our Link button that when it is tapped will bring us to my swifttom.com webpage.</p><p>Hope you enjoyed this quick look at how we can use Link views to our SwiftUI project.</p><p>For more on how to use Link views we can check out Apple's Documentation <a href="https://developer.apple.com/documentation/swiftui/link">here</a>.</p><p>üîóüîóüîó Happy Coding! üîóüîóüîó</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-12-03-how-to-blur-a-view-in-swiftui</guid><title>"How to Blur a View in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-12-03-how-to-blur-a-view-in-swiftui</link><pubDate>Thu, 3 Dec 2020 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>How to Blur a View in SwiftUI</h1><p>SwiftUI makes it easy to add a blur effect to any view. All we need to do is add the <strong>.blur()</strong> modifier to our view. Let‚Äôs see how we can apply this by looking at the example below.</p><p>import SwiftUI import PlaygroundSupport struct ContentView: View { var body: some View { ZStack { Color.green.edgesIgnoringSafeArea(.all) Text("Hello Tom") } } } PlaygroundPage.current.setLiveView(ContentView())</p><img src="https://swifttom.com/wp-content/uploads/2020/12/img_0039.png?w=460"/><p>As you can see in the example we have a <strong>ZStack</strong> with a green background and a text view. If we want to add a blur effect to our text view all we need to do is add the <strong>.blur()</strong> modifier to it.</p><p>import SwiftUI import PlaygroundSupport struct ContentView: View { var body: some View { ZStack { Color.green.edgesIgnoringSafeArea(.all) Text("Hello Tom") .blur(radius: 1.5) } } } PlaygroundPage.current.setLiveView(ContentView())</p><img src="https://swifttom.com/wp-content/uploads/2020/12/img_0038.png?w=460"/><p>As you can see above we added the blur effect with a <strong>1.5 radius</strong> to our ‚ÄúHello Tom‚Äù text view. It is good to know that the higher the radius the more blurry the view will appear.</p><p>Thanks for reading and happy coding!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-11-23-how-to-use-sf-symbols-in-a-swiftui-project</guid><title>"How to Use SF Symbols in a SwiftUI project"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-11-23-how-to-use-sf-symbols-in-a-swiftui-project</link><pubDate>Mon, 23 Nov 2020 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>How to Use SF Symbols in a SwiftUI project</h1><p>SF Symbols are set of over 2,000 symbols created by Apple for developers to use in there apps. SF Symbols are dynamic. This means that they will automatically align with the size and weight of text in our app. We can use these symbols for almost anything but they are most commonly used in toolbars, menus, and navigation bars.</p><p>We can use SF Symbols in our project by using the <strong>Image(systemName:)</strong> image view. In the system name parameter we will add the string of the SF Symbol we want to use.</p><blockquote><p>Image(systemName: ‚Äúcloud.sun.fill‚Äù)</p></blockquote><p>As you can see in the example above we added the ‚Äúcloud.sun.fill‚Äù SF Symbol to our image view.</p><p>We can also customize SF Symbols. If we want to change something like the color of our SF Symbol all we need to do is change the .<strong>foregroundColor()</strong>. We can also change the size of our symbol by changing the <strong>.font</strong> size.</p><blockquote><p>Image(systemName: "cloud.heavyrain.fill") .foregroundColor(.green) .font(.title)</p></blockquote><p>That was a quick look at how we can add SF Symbols to our SwiftUI projects. For more info checkout Apples <a href="https://developer.apple.com/design/human-interface-guidelines/sf-symbols/overview/">Human Interface Guidelines</a> on how you should use SF Symbols in our projects.</p><p>Thanks for reading and Happy Coding!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-11-11-access-control-in-swift</guid><title>"Access Control in Swift"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-11-11-access-control-in-swift</link><pubDate>Wed, 11 Nov 2020 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>Access Control in Swift</h1><p>What is Access Controls in Swift? According to the documentation <strong>"Access control restricts access to parts of your code from code in other source files and modules. This feature enables you to hide the implementation details of your code, and to specify a preferred interface through which that code can be accessed and used."</strong> We can implement access controlS by adding five different types of modifiers to our code. These modifiers are:</p><ul><li><strong>Public:</strong> Which means anyone can read and write to this property.</li><li><strong>Internal:</strong> This is the default access control for any property we create. This allows us access within the same module.</li><li><strong>File Private:</strong> Like the name says, this modifier allows us to only access this property within the same file.</li><li><strong>Private:</strong> This is the most restrictive. This only allows access within the current enclosing it is being used in.</li><li><strong>Open:</strong> This is the most unrestricted. This property can be accessed from anywhere and other developers can subclass it and/or override it.</li></ul><p>If you would like a deeper dive into Access Control check out the <a href="https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html">Swift Documentation</a> on it.</p><p>Thanks for reading and I hope this gives you a better understand of when to use Access Controls in Swift.</p><p>Happy Coding!!!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-11-05-how-to-make-static-and-dynamic-home-screen-quick-actions-in-swiftui</guid><title>"How to Make Static and Dynamic Home Screen Quick Actions in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-11-05-how-to-make-static-and-dynamic-home-screen-quick-actions-in-swiftui</link><pubDate>Thu, 5 Nov 2020 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>How to Make Static and Dynamic Home Screen Quick Actions in SwiftUI</h1><img src="https://swifttom.com/wp-content/uploads/2020/11/screen-shot-2020-11-04-at-6.13.48-pm.png?w=558"/><p>Home screen quick actions are shortcuts for users to navigate into different parts of our app. In this post we are going to see how we can add these quick actions into our SwiftUI project. The two different types of quick actions we can use is <strong>static quick actions</strong> and <strong>dynamic quick actions</strong>. Let's start by taking a look at how we can add static quick actions to our project.</p><p>As the name implies <strong>static quick actions</strong> do not change. If we want to add <strong>static quick actions</strong> to our project we will need to implement it in our <strong>info.plist</strong>. If we right click on the <strong>info.plist</strong> and go to <strong>&gt;¬†Open As¬†&gt; Source Code</strong> and at the bottom before the last **</dict>** add the following code below.

	<key>UIApplicationShortcutItems</key>
	<array>
		<dict>
			<key>UIApplicationShortcutItemType</key>
			<string>AddAction</string>
			<key>UIApplicationShortcutItemIconType</key>
			<string>UIApplicationShortcutIconTypeAdd</string>
			<key>UIApplicationShortcutItemTitle</key>
			<string>Add</string>
			<key>UIApplicationShortcutItemSubtitle</key>
			<string>Add Item</string>
		</dict>
	</array>

In the code above we are using **UIApplicationShortcutItems** to create an add button for our quick action shortcuts. Our shortcut items can be found inside an array of a dictionary. In each dictionary a¬†**UIApplicationShortcutItemType**¬†and¬†**UIApplicationShortcutItemTitle**¬†are needed to make our static shortcut. **UIApplicationShortcutItemType** is a string that represents what kind of quick action we want in our app. **UIApplicationShortcutItemTitle** is the title or name of our quick action button.

If you want to learn more about **UIApplicationShortcutItem**'s check out the Apple¬†[documentation](https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW36).

Now if you run the app and then go to the home screen we can test our quick action. On the home screen if we tap and hold on our app icon we should see the ‚ÄúAdd‚Äù quick action button pop up on our home screen.

Now that we made a static quick action let's move on to adding a dynamic quick action button.

To make a dynamic quick action we will need to add them in the **App** struct also known as the entry point of our app. This file can be located in the navigator and is usually named after your project name followed by the word **App**. In this example it will be in the **QuickActionSwuiftUIBlogApp.swift** file.

The reason we need to create our quick action buttons in this file is because these buttons need to be made at specific point in the apps life cycle. Apples documentation recommends that we create dynamic quick actions when the app is moving to the background.

import SwiftUI

@main
struct QuickActionSwuiftUIBlogApp: App {
    @Environment(\\.scenePhase) var lifeCycle
    
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
        .onChange(of: lifeCycle) { (newLifeCyclePhase) in
            switch newLifeCyclePhase {
            case .active :
                print("App is active")
            case .inactive:
                print("App is inactive")
            case .background:
                print("App is going to the Background")
                // This will add our dynamic quick actions when our app is sent to the background on our device
                addQuickActions()
            @unknown default:
                print("default")
            }
        }
    }
    
    func addQuickActions() {
        UIApplication.shared.shortcutItems = \[
            UIApplicationShortcutItem(type: "Tweet", localizedTitle: "Tweet"),
            UIApplicationShortcutItem(type: "Call", localizedTitle: "Call"),
            UIApplicationShortcutItem(type: "Message", localizedTitle: "Message"),
            UIApplicationShortcutItem(type: "Saved", localizedTitle: "Saved"),
        \]
    }
}

As you can see in the code above we created some dynamic shortcuts buttons in our **addQuickActions()** function. We call the **addQuickActions()** function to make our dynamic buttons when our app goes into the background state. We know when our app goes to the background by using the **.onChange** modifier with our **@Environment(\\.scenePhase) var lifeCycle** variable. For a deeper dive please check out the [Apple documentation](https://developer.apple.com/documentation/uikit/menus_and_shortcuts/add_home_screen_quick_actions).

Now if we rerun our app and long press on our app icon we should see our static quick action button with our dynamic quick action buttons underneath. You may also notice that one of our quick buttons doesn't show up in the quick action sheet. This is because Apple will only show a maximum of 4 quick actions at a time.

Next we will go back into our **addQuickActions()** function and add some more code.

    func addQuickActions() {
        var tweetuserInfo: \[String: NSSecureCoding\] {
                    return \["name" : "tweet" as NSSecureCoding\]
                }
                var calluserInfo: \[String: NSSecureCoding\] {
                    return \["name" : "call" as NSSecureCoding\]
                }
                var messageuserInfo: \[String: NSSecureCoding\] {
                    return \["name" : "message" as NSSecureCoding\]
                }
                var saveduserInfo: \[String: NSSecureCoding\] {
                    return \["name" : "saved" as NSSecureCoding\]
                }
        
        UIApplication.shared.shortcutItems = \[
            UIApplicationShortcutItem(type: "Tweet", localizedTitle: "Tweet", localizedSubtitle: "", icon: UIApplicationShortcutIcon(type: .compose), userInfo: tweetuserInfo),
            UIApplicationShortcutItem(type: "Call", localizedTitle: "Call", localizedSubtitle: "", icon: UIApplicationShortcutIcon(type: .audio), userInfo: calluserInfo),
            UIApplicationShortcutItem(type: "Message", localizedTitle: "Message", localizedSubtitle: "", icon: UIApplicationShortcutIcon(type: .message), userInfo: messageuserInfo),
            UIApplicationShortcutItem(type: "Saved", localizedTitle: "Saved", localizedSubtitle: "", icon: UIApplicationShortcutIcon(type: .love), userInfo: saveduserInfo),
        \]
    }

The example above will help us to identify each quick action button with a name key. This will allow us to know which of our quick actions was pressed this way we can have our app react according to what quick action the user has tapped. We will attach these new variables we created to the **userInfo** parameter of our **UIApplicationShortcutItem**. Above we also added icons to the shortcut items so we don't just have dots as icon placeholders.

Now let's add two global variables above our **@main** in our **App** file. These variables will help us to pass our users input along to different areas of our app depending on which quick action we press.

var shortcutItemToHandle: UIApplicationShortcutItem?
let quickActionSettings = QuickActionSettings()

Next we will need to add two more functions below our **addQuickActions()** function.

    class AppDelegate: NSObject, UIApplicationDelegate {
        func application(\_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {
            if let shortcutItem = options.shortcutItem {
                shortcutItemToHandle = shortcutItem
            }
            
            let sceneConfiguration = UISceneConfiguration(name: "Custom Configuration", sessionRole: connectingSceneSession.role)
            sceneConfiguration.delegateClass = CustomSceneDelegate.self
            
            return sceneConfiguration
        }
    }

    class CustomSceneDelegate: UIResponder, UIWindowSceneDelegate {
        func windowScene(\_ windowScene: UIWindowScene, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -> Void) {
            shortcutItemToHandle = shortcutItem
        }
    }

In the code above we added an **Appdelegate** method and a **Scenedelegate** method to handle what happens to our quick action buttons at different parts of the life cycle of our app. What these two class methods are doing is handling if the app is closed we want it to open our application and if our app is in the background to handle a quick action if the user taps on it.

Now that we have set up our quick action buttons we will want them to do something when a user taps on them. We want the user to be able to navigate to the specific section they tapped on in the home screen shortcut. This means that in our **newLifeCyclePhase** switch statement in our **.active** case we will need to perform an action. Let's take a look at how we implement this in the code below.

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(quickActionSettings)
        }
        .onChange(of: lifeCycle) { (newLifeCyclePhase) in
            switch newLifeCyclePhase {
            case .active :
                print("App is active")
                guard let name = shortcutItemToHandle?.userInfo?\["name"\] as? String else { return }
            case .inactive:
                print("App is inactive")
            case .background:
                print("App is going to the Background")
                // This will add our dynamic quick actions when our app is sent to the background on our device
                addQuickActions()
            @unknown default:
                print("default")
            }
        }
    }

Above we added a **guard let** variable to our **.active** case. This will check to see if we have a name attached to the button the user pressed on the quick action shortcuts.

Now that we set that up we will go into the **ContentView.swift** and we are going to make a simple list view that will correspond to our quick action dynamic buttons. This will also be where we setup a observable variable to see which button has been pressed from our App file and react by bringing our user to that view in the app.

Our **ContentView.swift** file should have the following code in it.

import SwiftUI

struct ContentView: View {
    @EnvironmentObject var quickActionSettings: QuickActionSettings
    @State var selectedAction: Int?

    var body: some View {
            NavigationView {
                List {
                    ForEach(0..<allQuickActions.count) { index in
                        NavigationLink(destination: DetailView(name: allQuickActions\[index\].name), tag: allQuickActions\[index\].tag, selection: $quickActionSettings.quickAction) {
                            Text(allQuickActions\[index\].name)
                        }
                    }
                }
                .listStyle(SidebarListStyle())
                .navigationBarTitle("Quick Actions")
            }
        }
    
}

struct ContentView\_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

    struct QuickActionModel : Identifiable {
        let id = UUID()
        let name: String
        let tag: QuickActionSettings.QuickAction
    }

    let allQuickActions = \[
        QuickActionModel(name: "Tweet", tag: .details(name: "tweet")),
        QuickActionModel(name: "Call",tag: .details(name: "call")),
        QuickActionModel(name: "Message", tag: .details(name: "message")),
        QuickActionModel(name: "Saved", tag: .details(name: "save")),
    \]

As you can see in the example we added a **@EnvironmentObject** to track which quick action our user has tapped from our quick actions on the home screen. We also setup a simple list view with all of our dynamic quick action buttons. We created a **QuickActionModel** struct with a name and a tag and created an array of quick actions so that we can segue to the detail view depending on which quick action was tapped.

Next we will need to make a new SwiftUI file called **DetailView**. In this file add the following code to make a simple view for our list view buttons to segue too. This detail view will just show the name of the button we selected.

import SwiftUI

struct DetailView: View {
    var name: String
    
    var body: some View {
        Text("\\(name)!")
            .navigationBarTitle(name)
    }
}

Now we will make another swift file and name this one **QuickActionSettings**. This will be our observable object so we can keep track of which quick action was pressed.

import Foundation

class QuickActionSettings: ObservableObject {
    
    enum QuickAction: Hashable {
        case home
        case details(name: String)
    }
    
    @Published var quickAction: QuickAction? = nil
}

Here we are using a **QuickAction** enum to see if the name value changes. If it does change it will trigger our navigation link in our content view to segue to the quick action the user has tapped.

Lastly let's go back to our App file and add our **.enviormentObject** to our **ContentView()** in our WindowGroup like below.

WindowGroup {
            ContentView()
                // We will use this modifier below to pass along which quick action that was pressed
                .environmentObject(quickActionSettings)
        }

We also need to update our code inside of our **.active** case. Here we will add another switch statement that will check the names associated with our quick actions buttons. We will then take this name variable and pass it along our **quickActionSettings.quickAction** so the rest of our app can update. Our final **QuickActionSwuiftUIBlogApp** file should look like the code below.

import SwiftUI

let quickActionSettings = QuickActionSettings()
var shortcutItemToHandle: UIApplicationShortcutItem?

@main
struct QuickActionSwuiftUIBlogApp: App {
    @Environment(\\.scenePhase) var lifeCycle
    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                // We will use this modifier below to pass along which quick action was pressed
                .environmentObject(quickActionSettings)
        }
        .onChange(of: lifeCycle) { (newLifeCyclePhase) in
            switch newLifeCyclePhase {
            case .active :
                print("App is active")
                guard let name = shortcutItemToHandle?.userInfo?\["name"\] as? String else { return }
                switch name {
                               case "tweet":
                                   print("tweet is selected")
                                   quickActionSettings.quickAction = .details(name: name)
                               case "call":
                                   print("call is selected")
                                   quickActionSettings.quickAction = .details(name: name)
                               case "message":
                                   print("message is selected")
                                   quickActionSettings.quickAction = .details(name: name)
                               case "saved":
                                   print("saved is selected")
                                   quickActionSettings.quickAction = .details(name: name)
                               default:
                                   print("default ")
                               }
            case .inactive:
                print("App is inactive")
            case .background:
                print("App is going to the Background")
                // This will add our dynamic quick actions when our app is sent to the background on our device
                addQuickActions()
            @unknown default:
                print("default")
            }
        }
    }
    
    func addQuickActions() {
        var tweetuserInfo: \[String: NSSecureCoding\] {
                    return \["name" : "tweet" as NSSecureCoding\]
                }
                var calluserInfo: \[String: NSSecureCoding\] {
                    return \["name" : "call" as NSSecureCoding\]
                }
                var messageuserInfo: \[String: NSSecureCoding\] {
                    return \["name" : "message" as NSSecureCoding\]
                }
                var saveduserInfo: \[String: NSSecureCoding\] {
                    return \["name" : "saved" as NSSecureCoding\]
                }
        
        UIApplication.shared.shortcutItems = \[
            UIApplicationShortcutItem(type: "Tweet", localizedTitle: "Tweet", localizedSubtitle: "", icon: UIApplicationShortcutIcon(type: .compose), userInfo: tweetuserInfo),
            UIApplicationShortcutItem(type: "Call", localizedTitle: "Call", localizedSubtitle: "", icon: UIApplicationShortcutIcon(type: .audio), userInfo: calluserInfo),
            UIApplicationShortcutItem(type: "Message", localizedTitle: "Message", localizedSubtitle: "", icon: UIApplicationShortcutIcon(type: .message), userInfo: messageuserInfo),
            UIApplicationShortcutItem(type: "Saved", localizedTitle: "Saved", localizedSubtitle: "", icon: UIApplicationShortcutIcon(type: .love), userInfo: saveduserInfo),
        \]
    }
    
    class AppDelegate: NSObject, UIApplicationDelegate {
        func application(\_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {
            if let shortcutItem = options.shortcutItem {
                shortcutItemToHandle = shortcutItem
            }
            
            let sceneConfiguration = UISceneConfiguration(name: "Custom Configuration", sessionRole: connectingSceneSession.role)
            sceneConfiguration.delegateClass = CustomSceneDelegate.self
            
            return sceneConfiguration
        }
    }

    class CustomSceneDelegate: UIResponder, UIWindowSceneDelegate {
        func windowScene(\_ windowScene: UIWindowScene, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -> Void) {
            shortcutItemToHandle = shortcutItem
        }
    }
}

If we test our code on our home screen we should be able to long press our icon and if we tap one of the dynamic quick action buttons it will open our app and navigate to that specific section of our app.

That is all you need to make home screen quick action shortcuts in SwiftUI.

All the code can be found here on my [Github](https://github.com/Tprezioso/QuickActionSwiftUIBlog).

I hope this helped you add quick actions to your next SwiftUI project.

Happy Coding!
</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-10-23-how-to-make-a-expandable-button-in-swiftui</guid><title>"How to Make a Expandable Button in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-10-23-how-to-make-a-expandable-button-in-swiftui</link><pubDate>Fri, 23 Oct 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>How to Make a Expandable Button in SwiftUI</h1><p>In this post we are going to learn how to make a SwiftUI button that expands out to show more button options. Below is an example of what our button will look like when we are finished.</p><img src="https://swifttom.com/wp-content/uploads/2020/10/screen-shot-2020-10-21-at-5.47.55-pm-1.png?w=508"/><p>Let's get started by creating a new SwiftUI project.</p><p>In our project let's add a new SwiftUI file and name it <strong>ExpandableButton</strong>. Inside of our <strong>ExpandableButton.swift</strong> file we will add the following code.</p><p>import SwiftUI</p><p>struct ExpandableButton: View { var body: some View { Button(action: { print("Expandable button tapped!!!") }) { Image(systemName: "plus.circle.fill") .resizable() .frame(width: 75, height: 75) .foregroundColor(.green)</p><p>}<br> } }</p><p>In the code above all we did was create a button and stylize it. Next we will need to wrap our button in a <strong>VStack</strong> so that when we add our menu buttons they will appear above our expandable button.</p><p>import SwiftUI</p><p>struct ExpandableButton: View { var body: some View { VStack { Button(action: { print("Expandable button tapped!!!") }) { Image(systemName: "plus.circle.fill") .resizable() .frame(width: 75, height: 75) .foregroundColor(.green)</p><p>} }<br> } }</p><p>Now let's create our menu buttons in a new SwiftUI file. We will name this file <strong>MenuButtons</strong> and we will add the following code to it.</p><p>import SwiftUI</p><p>struct MenuButtons: View { var buttonImage: String<br> var body: some View { Button(action: { print("Menu Button tapped")<br> }) { ZStack { Circle() .foregroundColor(.green) .frame(width: 50, height: 50)<br> Image(systemName: buttonImage) .imageScale(.large) .foregroundColor(.white)<br> } } } }</p><p>In the code above we made our menu buttons similar to how we created our expandable button. The only difference is that our menu buttons are slightly smaller and have a green circular background. We also added a <strong>buttonImage</strong> variable so that we can change the image that appears on our menu button.</p><p>Now that we have our menu button created let's go back and add it to our <strong>ExpandableButton.swift</strong> file. First we will need to create a <strong>@State</strong> variable so that we can control when we show our menu buttons. In this example we will name are state property <strong>isExpanded</strong> and set it to false.</p><p>@State var isExpanded = false</p><p>Next we will add a conditional statement above our expandable button that will check if our button is expanded. If <strong>isExpanded</strong> returns true we will show our the menu buttons.</p><p>if isExpanded { MenuButtons(buttonImage: "camera.fill") MenuButtons(buttonImage: "record.circle.fill") MenuButtons(buttonImage: "photo") }</p><p>In the action of our expandable button we will toggle our <strong>isExpanded</strong> property so that we can control when to show and hide our menu buttons. We'll also add an animation so that when the expandable button is pressed our button will have a smooth transition. Our code should now look like the example below.</p><p>import SwiftUI</p><p>struct ExpandableButton: View {<br> @State var isExpanded = false<br> var body: some View { VStack { if isExpanded { MenuButtons(buttonImage: "camera.fill") MenuButtons(buttonImage: "record.circle.fill") MenuButtons(buttonImage: "photo") }<br> Button(action: { print("Expandable button tapped!!!") isExpanded.toggle()<br> }) { Image(systemName: "plus.circle.fill") .resizable() .frame(width: 75, height: 75) .foregroundColor(.green) }<br><br> } .animation(.spring()) } }</p><p>Now if we go and run our preview canvas we should see our button. If we go and tap our button then we should see our menu buttons pop up with an animation.</p><img src="https://swifttom.com/wp-content/uploads/2020/10/screen-shot-2020-10-21-at-5.47.16-pm.png?w=505"/><img src="https://swifttom.com/wp-content/uploads/2020/10/screen-shot-2020-10-21-at-5.47.55-pm.png?w=508"/><p>Thanks for reading! I hope this helps you in your next SwiftUI project.</p><p>All the code from this post can be found on my <a href="https://github.com/Tprezioso/ExpandableButtonSwiftUI">Github</a>.</p><p>üì± Happy Coding! üíª</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-10-17-how-to-add-custom-modifiers-and-views-to-xcodes-library</guid><title>"How to Add Custom Modifiers and Views to Xcode's Library"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-10-17-how-to-add-custom-modifiers-and-views-to-xcodes-library</link><pubDate>Sat, 17 Oct 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>How to Add Custom Modifiers and Views to Xcode's Library</h1><p>SwiftUI allows us to add our own custom views and modifiers to Xcode's library. By doing this we are able to easily access our custom views and add them into our code in just a click. Let's see how we can take advantage of this in our own SwiftUI project.</p><p>First thing we will need is to add a new SwiftUI file to our project to store our custom views and modifiers. We'll name our file <strong>LibraryContent</strong> and replace the boilerplate code with the code in the example below.</p><p>import SwiftUI</p><p>struct LibraryContent: LibraryContentProvider { @LibraryContentBuilder var views: [LibraryItem] { LibraryItem(CloseButton(), category: .control) } }</p><p>In the example code we are creating a <a href="https://developer.apple.com/documentation/developertoolssupport/libraryitem">LibraryItem</a> so we can add our custom view to the Xcode library. We chose to add our custom close button because we will most likely use this view throughout the app and we will want to have quick access to it from our Xcode library.</p><p>If we dive into the Documentation for <a href="https://developer.apple.com/documentation/developertoolssupport/libraryitem">LibraryItem</a> we can see that we can add things like a title and category to our <a href="https://developer.apple.com/documentation/developertoolssupport/libraryitem">LibraryItem</a>. This is to help us better organization our views and modifiers in our Xcode Library. In our example we are adding the close button to the <strong>.control</strong> category. Also you will notice we didn't add a title to our <strong>LibraryItem</strong> but Xcode is smart enough to use the filename "CloseButton" as the title.</p><p>Now Xcode probably is showing some errors because it can't find our <strong>CloseButton</strong> view. Let's go ahead and create a new SwiftUI file and name it <strong>CloseButton</strong>.</p><p>In our <strong>CloseButton.swift</strong> file add the following code.</p><p>import SwiftUI</p><p>struct CloseButton: View { var body: some View { Image(systemName: "xmark") .font(.system(size: 17, weight: .bold)) .foregroundColor(.white) .padding(.all, 10) .background(Color.black.opacity(0.6)) .clipShape(Circle()) } }</p><p>struct CloseButton_Previews: PreviewProvider { static var previews: some View { CloseButton() } }</p><p>If we go and run the preview canvas in <strong>CloseButton.swift</strong> we should see a circular button with an <strong>X</strong> in the center.</p><p>Now if we go to our Xcode library we can see that our close button has been added. We can open up our Xcode library by going to the <strong>+</strong> button in the top right of Xcode or by using the keyboard shortcut <strong>Command + Shift + L</strong>.</p><p>Now that the Xcode library is open we can use its search bar at the top to search for our custom "Close button". Like in the image below we should see our new custom view show up and allow us to drag and drop it or double click on it to add it to our current SwiftUI file.</p><img src="https://swifttom.com/wp-content/uploads/2020/10/screen-shot-2020-10-13-at-3.39.02-pm.png?w=1024"/><p>We can also add custom modifiers to our library like we did our custom view.</p><p>To add a reusable modifier we will need to add a <strong>View</strong> extension to our <strong>LibraryContent.swift</strong> file. Inside of the extension we will need to create a function that returns a view with the modifiers we want added.</p><p>Let's take a look at the example code below.</p><p>extension View { func customViewStyle() -&gt; some View { return self .background(Color.red) .cornerRadius(22) .shadow(color: Color.red.opacity(0.3), radius: 20, x: 0, y: 10)</p><p>} }</p><p>Above we created our <strong>customViewStyle()</strong> function which is returning a view with 3 custom modifiers.</p><p>With just this code we can now go to any file in our project and apply our new custom modifier. Let's see this in action by going to our <strong>ContentView.swift</strong> file. At the end of the Hello World text view we can add our new modifier.</p><p>import SwiftUI</p><p>struct ContentView: View { var body: some View { Text("Hello, world!") .padding() .customViewStyle() } }</p><img src="https://swifttom.com/wp-content/uploads/2020/10/screen-shot-2020-10-14-at-5.25.26-pm.png?w=503"/><p>This is great but the only problem is that our new modifier for our view doesn't show up in our Xcode library.</p><p>Let's go back to the <strong>LibraryContent.swift</strong> file and under our <strong>CloseButton()</strong> let's add another <strong>@LibraryContentBuilder</strong> with the following code.</p><p>@LibraryContentBuilder func modifiers(base: Image) -&gt; [LibraryItem] { LibraryItem( base.customViewStyle(), title: "Custom View Style 1", category: .effect ) }</p><p>As you can see in the example above this code is very similar to how we added our custom close button to our library. Now if we go to our library with the second tab selected and search for our modifier we will see our "Custom View Style 1" modifier has been added.</p><img src="https://swifttom.com/wp-content/uploads/2020/10/screen-shot-2020-10-14-at-5.37.05-pm.png?w=1024"/><p>Lastly let's make our custom modifier customizable. We are going to change the hard coded values into variables so that anyone that is using our modifier can style it to their liking. Let's go back to our <strong>LibraryContent.swift</strong> file and add the following changes to our code.</p><p>@LibraryContentBuilder func modifiers(base: Image) -&gt; [LibraryItem] { LibraryItem( // Added default values for our customViewStyle function<br> base.customViewStyle(color: Color.red, cornerRadius: 22), title: "Custom View Style 1", category: .effect ) } }</p><p>extension View { // Add variables to our function so we can customize it to our like for the specific view we are working on<br> func customViewStyle(color: Color, cornerRadius: CGFloat) -&gt; some View { return self .background(color) .cornerRadius(cornerRadius) .shadow(color: color.opacity(0.3), radius: 20, x: 0, y: 10)</p><p>} }</p><p>As you can see in the code above we added variables to our <strong>customViewStyle()</strong> function so we can change the color and the corner radius to whatever value we want. We also added our previously hard coded values as the default values for our modifier. Let's go back to our <strong>ContentView.swift</strong> file and apply our updated modifier to the Hello World text view.</p><p>import SwiftUI</p><p>struct ContentView: View { var body: some View { Text("Hello, world!") .padding() .customViewStyle(color: .green, cornerRadius: 10) } }</p><img src="https://swifttom.com/wp-content/uploads/2020/10/screen-shot-2020-10-14-at-5.48.55-pm.png?w=505"/><p>Hope this helps you on your next SwiftUI project!</p><p>Thanks for reading!</p><p>All the code in this post can be found on my <a href="https://github.com/Tprezioso/AddingCustomLibraryComponents">Github</a>.</p><p>üë®üèª‚Äçüíª Happy coding! üë®üèª‚Äçüíª</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-10-08-how-to-make-a-placeholder-view-in-swiftui-using-the-redacted-modifier</guid><title>"How to Make a Placeholder View in SwiftUI using the Redacted Modifier"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-10-08-how-to-make-a-placeholder-view-in-swiftui-using-the-redacted-modifier</link><pubDate>Thu, 8 Oct 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>How to Make a Placeholder View in SwiftUI using the Redacted Modifier</h1><p>As of iOS 14 we can now use the new <strong><a href="https://developer.apple.com/documentation/swiftui/view/redacted(reason:)">.redacted(reason:)</a></strong> modifier in SwiftUI to make placeholders for our views. Let's take a look at the example below to get a better understanding of how we can add placeholders to our SwiftUI project.</p><p>Text("Hello world!") .padding() .redacted(reason: .placeholder)</p><ul><li><img src="https://swifttom.com/wp-content/uploads/2020/10/screen-shot-2020-10-06-at-5.58.32-pm-2.png?w=514"/><ul></ul></li></ul><ul><li><img src="https://swifttom.com/wp-content/uploads/2020/10/screen-shot-2020-10-06-at-5.58.48-pm-1.png?w=509"/><ul></ul></li></ul><p>By adding the redacted modifier our users will get a outline preview of our content. This is great to use when content is being loaded to our views.</p><p>We can also redact groups of SwiftUI views. Let's write some code to see how we can implement this in a example. First let's create a new SwiftUI file and name it ComplexView. Next let's add the following code below.</p><p>import SwiftUI</p><p>struct ComplexView: View { var body: some View { VStack(alignment: .leading) { Spacer() Image("husky") .resizable() .frame(width: 200, height: 200) .clipShape(Circle()) Text("Husky World!") .font(.title) .fontWeight(.bold) Spacer() Text("A husky is a sled dog used in the polar regions. One can differentiate huskies from other dog types by their fast pulling-style. They represent an ever-changing crossbreed of the fastest dogs (the Alaskan Malamute, by contrast, pulled heavier loads at a slower speed). Humans use huskies in sled-dog racing. Various companies have marketed tourist treks with dog sledges for adventure travelers in snow regions. Huskies are also kept as pets, and groups work to find new pet homes for retired racing and adventure-trekking dogs.") HStack() { Spacer() Button("More Huskies!") { print("Huskies!!!!") } .padding() .font(.system(size: 32)) Spacer() } Spacer() } .padding() } }</p><p>We should now see a view about huskies in our preview canvas!</p><img src="https://swifttom.com/wp-content/uploads/2020/10/screen-shot-2020-10-06-at-6.44.59-pm.png?w=511"/><p>Now if we go to our ContentView.Swift file we can add our ComplexView() to our body. Here we will add the redacted modifier to the ComplexView to redact all of the views inside of the container.</p><p>import SwiftUI</p><p>struct ContentView: View { var body: some View { ComplexView() .redacted(reason: .placeholder) } }</p><img src="https://swifttom.com/wp-content/uploads/2020/10/screen-shot-2020-10-06-at-6.47.35-pm.png?w=509"/><p>We can also redact specific views in our ComplexView.swift file. Let's say we wanted to show a placeholder for everything in our complex view except for our "Husky World!" text. We can simply go back to our ComplexView.swift file and add the <strong>.unredacted()</strong> modifier to our "Husky World!" text view.</p><p>struct ComplexView: View { var body: some View { VStack(alignment: .leading) { Spacer() Image("husky") .resizable() .frame(width: 200, height: 200) .clipShape(Circle()) Text("Husky World!") .font(.title) .fontWeight(.bold) // Added Unredacted .unredacted() Spacer() Text("A husky is a sled dog used in the polar regions. One can differentiate huskies from other dog types by their fast pulling-style. They represent an ever-changing crossbreed of the fastest dogs (the Alaskan Malamute, by contrast, pulled heavier loads at a slower speed). Humans use huskies in sled-dog racing. Various companies have marketed tourist treks with dog sledges for adventure travelers in snow regions. Huskies are also kept as pets, and groups work to find new pet homes for retired racing and adventure-trekking dogs.") HStack() { Spacer() Button("More Huskies!") { print("Huskies!!!!") } .padding() .font(.system(size: 32)) Spacer() } Spacer() } .padding() } }</p><p>Now when we look at our preview for our Complex view we should see everything redacted except "Husky World!".</p><img src="https://swifttom.com/wp-content/uploads/2020/10/screen-shot-2020-10-06-at-6.55.30-pm.png?w=510"/><p>It is good to note that buttons are not disabled when using the redacted modifier. This means users can still tap on buttons while the placeholder for the button is being shown. You will need to use a @State or @Enviorment variable to handle disabling any buttons in your view so that button actions won't get triggered as your redacted view is being shown.</p><p>The example code for this post can be found on my <a href="https://github.com/Tprezioso/PlaceholderViewInSwiftUIBlog">GitHub</a>.</p><p>Thanks for reading my post and I hope this helps in your next SwiftUI project.</p><p>Happy Coding!</p><img src="https://tprezioso.github.io//images/giphy.gif" alt="Redact GIFs - Get the best GIF on GIPHY"/>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-09-28-how-to-add-sign-in-with-apple-to-a-swiftui-project</guid><title>"How to Add Sign In with Apple to a SwiftUI Project"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-09-28-how-to-add-sign-in-with-apple-to-a-swiftui-project</link><pubDate>Mon, 28 Sep 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>How to Add Sign In with Apple to a SwiftUI Project</h1><p><strong>Sign in with Apple</strong> makes it safe and secure for users to login to websites and apps. We can implement <a href="https://developer.apple.com/documentation/sign_in_with_apple?language=data">Sign in with Apple</a> easily with SwiftUI 2. For us to use <strong>Sign in with Apple</strong> in our app we are required to use <strong>iOS 14</strong> or later and <strong>Xcode 12</strong> or later.</p><p>The first thing we need to do is go to our project file which is located at the top of our navigator on the left side of Xcode. Then we need to go to the <strong>Signing &amp; Capabilities</strong> tab. In the left corner of this tab we need to click on the <strong>+ Capability</strong> button and type in Sign in with Apple. Then press enter to add it to our project.</p><img src="https://swifttom.com/wp-content/uploads/2020/09/screen-shot-2020-09-28-at-12.13.37-pm.png?w=1024"/><p>Now let's navigate to our <strong>ContentView.swift</strong> file to get started.</p><p>We need to open our library to get a <strong>Sign in with Apple</strong> Button for our project. We can use the keyboard shortcut <strong>Command + Shift + L</strong> to bring up our library. In the search bar we can type in Sign in with Apple and drag and drop our <strong>Sign in with Apple</strong> button into either our code or onto our canvas.</p><img src="https://swifttom.com/wp-content/uploads/2020/09/screen-shot-2020-09-28-at-10.29.10-am.png?w=1024"/><p>Now you might have a error pop up that says Xcode can not find <strong>Sign in with Apple</strong> in our scope. All you have to do to get rid of this error is <strong>import AuthenticationServices</strong> at the top of our <strong>ContentView.swift</strong> file. Now let's add the code in the example below to our project and we will walk through what we are implementing in our app.</p><p>import SwiftUI import AuthenticationServices</p><p>struct ContentView: View { var body: some View { SignInWithAppleButton( // 1. onRequest: { request in request.requestedScopes = [.fullName, .email] }, onCompletion: { result in switch result { // 2. case .success (let authenticationResults): print("Authorization successful! :(authenticationResults)")</p><p>// 3. case .failure(let error): print("Authorization failed: " + error.localizedDescription) } } // 4. ).frame(width: 200, height: 50, alignment: .center) } }</p><ol><li>Here we are specify what kind of information we would like to get from our user. In this example we are requesting the users full name and email address to be used in our app.</li><li>If the request goes through successfully we can then gain access to the users information we requested. This would be the users full name and email address.</li><li>If something goes wrong this is where we will be able to show a error message to our user and notify them that something has gone wrong with using Sign in with Apple.</li><li>Lastly we are setting the frame of our button so our button won't take up the whole screen.</li></ol><p>Now when we run our app we should see a <strong>Sign in with Apple</strong> button.</p><img src="https://swifttom.com/wp-content/uploads/2020/09/simulator-screen-shot-iphone-11-pro-2020-09-28-at-12.06.50.png?w=473"/><p>When we tap on our button we should be prompted to authenticate using our full name and email.</p><img src="https://swifttom.com/wp-content/uploads/2020/09/simulator-screen-shot-iphone-11-pro-2020-09-28-at-12.24.44-1.png?w=473"/><p>We can switch the Sign in button to be a <strong>Continue with Apple</strong> button or a <strong>SignUp with Apple</strong> button by simply adding the following code at the top of our existing code.</p><p>import SwiftUI import AuthenticationServices</p><p>struct ContentView: View { var body: some View { SignInWithAppleButton( // Add this below for Sign up with Apple button .signUp,<br> onRequest: { request in request.requestedScopes = [.fullName, .email] }, onCompletion: { result in switch result { case .success (let authenticationResults): print("Authorization successful! :(authenticationResults)") case .failure(let error): print("Authorization failed: " + error.localizedDescription) } } ).frame(width: 200, height: 50, alignment: .center) } }</p><img src="https://swifttom.com/wp-content/uploads/2020/09/simulator-screen-shot-iphone-11-pro-2020-09-28-at-12.45.07.png?w=473"/><p>struct ContentView: View { var body: some View { SignInWithAppleButton( // Add this below for Continue with Apple button .continue,<br> onRequest: { request in request.requestedScopes = [.fullName, .email] }, onCompletion: { result in switch result { case .success (let authenticationResults): print("Authorization successful! :(authenticationResults)") case .failure(let error): print("Authorization failed: " + error.localizedDescription) } } ).frame(width: 200, height: 50, alignment: .center) } }</p><img src="https://swifttom.com/wp-content/uploads/2020/09/simulator-screen-shot-iphone-11-pro-2020-09-28-at-12.46.40.png?w=473"/><p>That's all there is to adding <strong>Sign in with Apple</strong> to our SwiftUI project. This blogs code can be found on my <a href="https://github.com/Tprezioso/Sign-In-with-Apple-SwiftUI-for-Blog">Github</a>. If you want to see how we can implement <strong>Sign in with Apple</strong> in <strong>UIKit</strong> please check out my other <a href="https://swifttom.com/2020/04/19/how-to-implement-sign-in-with-apple-in-swift/">blog post</a>.</p><p>Thanks for reading and I hope this helps you on your next SwiftUI project!</p><p>Í©úüíªüë®üèª‚Äçüíª Happy Coding! üë®üèª‚ÄçüíªüíªÍ©ú</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-09-22-how-to-make-a-sidebar-menu-in-swiftui</guid><title>"How to Make a Sidebar Menu in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-09-22-how-to-make-a-sidebar-menu-in-swiftui</link><pubDate>Tue, 22 Sep 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>How to Make a Sidebar Menu in SwiftUI</h1><p>Sidebars are really useful for navigating on bigger screen such as iPad's and the Mac's. We are going to take a look at how we can implement sidebars into a multiplatform SwiftUI app.</p><p>The first thing we need to do is open a new Xcode project and create a new SwiftUI file. In this example we are going to name our file <strong>SideBar</strong>. Inside the <strong>Sidebar</strong> file we are going to replace the boilerplate code with the code below.</p><p>struct Sidebar: View { var body: some View { NavigationView { List { Label("Books", systemImage: "book.closed") Label("Tutorials", systemImage: "list.bullet.rectangle") Label("Video Tutorials", systemImage: "tv") Label("Contacts", systemImage: "mail.stack") Label("Search", systemImage: "magnifyingglass") } .listStyle(SidebarListStyle()) .navigationTitle("Code") }</p><p>} }</p><img src="https://swifttom.com/wp-content/uploads/2020/09/screen-shot-2020-09-18-at-2.54.26-pm.png?w=395"/><p>In the above example we have created a simple list view with a few labels for our sidebar. Then we set our list with the sidebar style by simply adding the <strong>.listStyle(SidebarListStyle())</strong> modifier. We also added a navigation view so we can have a nice title label and add navigation to our sidebar labels in the future.</p><p>Now we are going to run this code on our iPad simulator and rotate our simulator 90¬∞. We can now see how our sidebar looks on a bigger iPad screen.</p><img src="https://swifttom.com/wp-content/uploads/2020/09/simulator-screen-shot-ipad-8th-generation-2020-09-18-at-18.19.27.png?w=1024"/><p>Let's fill in the blank space of our example to see how this would look in a real app. First we will remove the <strong>NavigationView</strong> from our Sidebar.swift file. Then we will go into our <strong>ContentView</strong> file and add the following code below.</p><p>struct ContentView: View { var body: some View { NavigationView { Sidebar() List(0 ..&lt; 20) {_ in Text("Book") } .navigationTitle("Book List") }<br><br> } }</p><p>Now when we run our application we get a mock book list next to our sidebar.</p><img src="https://swifttom.com/wp-content/uploads/2020/09/simulator-screen-shot-ipad-8th-generation-2020-09-18-at-18.34.04.png?w=1024"/><p>If we wanted to make this sidebar available on a Mac version of our app all we would need to do is add a few lines of code to our project.</p><p>The first thing we will need to do is extract out the code in between the <strong>NavigationView</strong> curly braces. We can do this by holding down the command button and clicking on <strong>List</strong>. Next scroll down and select <strong>Extract subview</strong>. We will rename our subview <strong>SideBarContent</strong>. Now we need to add <strong>#if</strong>, <strong>#else</strong>, and <strong>#endif</strong> under our NavigationView. This will allow us to specify how we want our sidebar layout to look for the different operating systems.</p><p>struct Sidebar: View { var body: some View { NavigationView { #if os(iOS) SideBarContent() .navigationTitle("Code") #else SideBarContent() .frame(minWidth: 200, idealWidth: 250,maxWidth: 300) #endif }</p><p>} }</p><p>The code above is allowing us to adapt our sidebar code to the different <strong>OS</strong>'s (Operating Systems) our app is going to run on. We need to separate our code because there are different requirements for running our code on the different operating systems. In the first part of our <strong>#if</strong> statement we are checking to see if our <strong>OS</strong> is iOS and if it is we are then setting our sidebar with a navigation title. We need to add our <strong>.navigationTitle()</strong> modifier here because it is not supported in MacOS. In the <strong>#else</strong> statement all we need to do is set the minimum frame of our Mac app's window. Lastly we end our if statement with the <strong>#endif</strong>.</p><p>Now we can run our sidebar code on both the iOS and MacOS (We need to have MacOS Big Sur installed on your Mac to run this on the Mac simulator).</p><p>That's all there is too adding a native sidebar to a multiplatform SwiftUI app. Feel free to check out the example code here on my <a href="https://github.com/Tprezioso/SideBarSwiftUI">Github</a>.</p><p>üíªüë®üèª‚Äçüíª Happy Coding! üíªüë®üèª‚Äçüíª</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-09-17-how-to-show-a-progressview-in-swiftui</guid><title>"How to Show a ProgressView in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-09-17-how-to-show-a-progressview-in-swiftui</link><pubDate>Thu, 17 Sep 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>How to Show a ProgressView in SwiftUI</h1><p>At WWDC 2020 Apple introduced <a href="https://developer.apple.com/documentation/swiftui/progressview"><strong>ProgressView</strong>'s</a> to SwiftUI. A <strong><a href="https://developer.apple.com/documentation/swiftui/progressview">ProgressView</a></strong> allows us to show either a circular progress view or a linear progress view for when tasks are loading in our app.</p><p>The first type of progress view we will look at is the <strong>Indeterminate Progress</strong> <strong>view</strong>. The indeterminate progress view creates a spinning loading view. The example below shows how we can easily add this into our code.</p><p>ProgressView()</p><p>We can also add text to the progress view by adding a string inside the parentheses.</p><p>ProgressView("Loading...")</p><img src="https://swifttom.com/wp-content/uploads/2020/09/screen-shot-2020-09-14-at-8.13.53-pm.png?w=266"/><p>The second type of progress view we will look at is the <strong>Linear Progress</strong> <strong>view</strong>. Linear progress views are great for when we have something loading and we want to show the progress to our user.</p><p>To make a linear progress view we need to specify two parameters, the <strong>current value</strong> and the <strong>total value</strong> of our progress view.</p><p>ProgressView("Downloading‚Ä¶", value: 25, total: 100)<br> .padding()</p><img src="https://swifttom.com/wp-content/uploads/2020/09/screen-shot-2020-09-14-at-10.28.48-pm.png?w=628"/><p>As you can see in the above example all we did was add a current value of 25 and a total value of 100. This shows our current progress as the blue line at 25% of our total value which is 100%.</p><p>We can see how a linear progress view works by adding a simple timer that changes the current value over time until it reaches our total value.</p><p>struct LinearProgressView: View { @State private var currentValue = 0.0 let timer = Timer.publish(every: 0.09, on: .main, in: .common).autoconnect()<br> var body: some View { ProgressView("Downloading‚Ä¶", value: currentValue, total: 100) .padding() .onReceive(timer) { _ in if currentValue &lt; 100 { currentValue += 1 } } } }</p><p>In the example above we added a <strong>@State</strong> property called <strong>currentValue</strong>. This will update the current progress of our linear progress view. Then we created and added our <strong>timer</strong> to the <strong>.onReceive</strong> modifier. This will update our <strong>currentValue</strong> variable every time our <strong>timer</strong> hits 0.09 seconds. We also check to make sure that the <strong>currentValue</strong> never exceeds the total value of the progress view because this can cause problems in your code and Xcode will yell at us.</p><p>Lastly we can customize your linear progress view by changing the accent color of the progress bar with the <strong>.accentColor</strong> modifier and by changing the text color by using the <strong>.foregroundColor</strong> modifier.</p><p>struct LinearProgressView: View { @State private var currentValue = 0.0 let timer = Timer.publish(every: 0.09, on: .main, in: .common).autoconnect()<br> var body: some View { ProgressView("Downloading‚Ä¶", value: currentValue, total: 100) .padding() .onReceive(timer) { _ in if currentValue &lt; 100 { currentValue += 1 } } .accentColor(.purple) .foregroundColor(.red) } }</p><img src="https://swifttom.com/wp-content/uploads/2020/09/screen-shot-2020-09-15-at-10.01.08-pm.png?w=612"/><p>If you would like to play around with these progress view examples please check out the code for this blog on my <a href="https://github.com/Tprezioso/ProgressViewSwiftUIBlog">Github</a>.</p><p>Hope this helps shed some light on how to use progress views in SwiftUI!</p><p>üíª Í©ú Happy Programming! Í©úüíª</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-09-02-how-to-show-a-menu-when-a-button-is-pressed-in-swiftui</guid><title>"How to Show a Menu When a Button is Pressed in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-09-02-how-to-show-a-menu-when-a-button-is-pressed-in-swiftui</link><pubDate>Wed, 2 Sep 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>How to Show a Menu When a Button is Pressed in SwiftUI</h1><p>As of iOS 14 and SwiftUI 2 we can now add a pop out menu to any button in our app. We can implement this by using the new <strong><a href="https://developer.apple.com/documentation/swiftui/menu?changes=latest_beta">Menu</a></strong> keyword. Menus in some way are going to replace the current action sheets used in iOS apps. The problem with action sheets is they only show up at the bottom of our screen. This doesn't look great on larger screens like the iPad and Mac. Menus allow the flexibility in where we would want to show pop out menus in our app instead of only showing them at the bottom of our screens.</p><p>Let's take a look at the example below of how we can implement this in our application.</p><p>struct ContentView: View { var body: some View {<br> Menu("Create") { Button("Cancel", action: {}) Button("Search", action: {}) Button("Add", action: {}) } } }</p><p>As you can see in the example above we use the <strong>Menu</strong> keyword and name our menu "<strong>Create</strong>". Next inside the menu curly braces we can add as many buttons as we want. The order of how we place the buttons in the menu does matter. The first button we create will always be at the bottom and whatever button we create next will be on top of the pervious the button. Take a look at the example below.</p><img src="https://swifttom.com/wp-content/uploads/2020/09/screen-shot-2020-08-31-at-8.08.59-pm.png?w=527"/><img src="https://swifttom.com/wp-content/uploads/2020/09/screen-shot-2020-08-31-at-8.09.14-pm.png?w=519"/><p>As you can see in the above example once our create button is tapped we can see our menu of buttons appear in the specific order we placed them in our code.</p><p>We can also have menus inside of menus.</p><p>struct ContentView: View { var body: some View {<br> Menu("Create") { Button("Cancel", action: {}) Menu("More") { Button("Rename", action: {}) Button("Developer Mode", action: {}) } Button("Search", action: {}) Button("Add", action: {}) } } }</p><img src="https://swifttom.com/wp-content/uploads/2020/09/screen-shot-2020-09-02-at-12.16.09-pm.png?w=526"/><img src="https://swifttom.com/wp-content/uploads/2020/09/screen-shot-2020-09-02-at-12.17.08-pm.png?w=530"/><p>Now if we tap on the Create button and then tap our More button we now get presented with our new menu inside of our main menu.</p><p>Lastly we can have customized text and icons in our menu by adding a label to our menu.</p><p>struct ContentView: View { var body: some View {<br> Menu { Button("Cancel", action: {}) Button("Search", action: {}) Button("Add", action: {}) } label: { Label("Create", systemImage: "plus.circle") } } }</p><img src="https://swifttom.com/wp-content/uploads/2020/09/screen-shot-2020-09-02-at-12.26.12-pm.png?w=516"/><img src="https://swifttom.com/wp-content/uploads/2020/09/screen-shot-2020-09-02-at-12.27.07-pm.png?w=528"/><p>As you can see in the above example now we can add a custom title and icon to our menu button.</p><p>There is a great <a href="https://developer.apple.com/videos/play/wwdc2020/10205">WWDC video</a> that can help explain menus if you are still confused.</p><p>I hope this helps you better understand how to use the menus in iOS 14 and SwiftUI 2.</p><p>üíªüë®üèª‚Äçüíª Happy coding! üíªüë®üèª‚Äçüíª</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-08-19-how-to-make-keyboard-shortcuts-in-swiftui</guid><title>"How to Make Keyboard Shortcuts in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-08-19-how-to-make-keyboard-shortcuts-in-swiftui</link><pubDate>Wed, 19 Aug 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>How to Make Keyboard Shortcuts in SwiftUI</h1><p>As of WWDC 2020, SwiftUI has made it insanely easy to add <a href="https://developer.apple.com/documentation/swiftui/keyboardshortcut">keyboard shortcuts</a> to any SwiftUI app. Let's look at how we can add keyboard shortcuts to our project by looking at the code example below.</p><p>struct ContentView: View { var body: some View {<br> Button(action: { print("Button Tapped!!") }) { Text("Button") }.keyboardShortcut("T")<br> } }</p><p>As you can see in the example above all we needed to do was add the <strong>.keyboardShortcut()</strong> modifier to our button and assign it a key. Now by holding the command button on our external keyboard and pressing "T", our action for our button will be triggered.</p><p>We can customize our shortcut by modifying which buttons need to be pressed.</p><p>.keyboardShortcut("T", modifiers: .control)</p><p>In the example above if we want to trigger our new modified shortcut we need to press the control button and the "T" button.</p><p>We can also use different combinations of modifier keys in an array.</p><p>.keyboardShortcut("T", modifiers: [.command, .control])</p><p>Like in the example before we need to hold the control and "T" key but now we also need to hold the command key to get our shortcut to work.</p><p>We can also use other keyboard keys like directional keys, spacebar, and many <a href="https://developer.apple.com/documentation/swiftui/keyequivalent">more</a>.</p><p>.keyboardShortcut("T", modifiers: [.command, .shift, .space])</p><p>Also be mindful that system keyboard shortcuts like cut, copy, and paste take priority over app shortcuts. Keep this in mind when assigning your keyboard shortcuts.</p><p>I hope this helps you to expand keyboard shortcuts to your SwiftUI app!</p><p>‚å®Ô∏è ü©≥ üíá‚Äç‚ôÇÔ∏è Happy Coding ‚å®Ô∏è ü©≥ üíá‚Äç‚ôÇÔ∏è</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-08-05-how-to-use-lazyvgrid-and-lazyhgrid-in-swiftui</guid><title>"How to use LazyVGrid and LazyHGrid in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-08-05-how-to-use-lazyvgrid-and-lazyhgrid-in-swiftui</link><pubDate>Wed, 5 Aug 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>How to use LazyVGrid and LazyHGrid in SwiftUI</h1><p>As of iOS 14, SwiftUI now gives developers two new UI components called <a href="https://developer.apple.com/documentation/swiftui/lazyvgrid">LazyVGrid</a> and <a href="https://developer.apple.com/documentation/swiftui/lazyhgrid">LazyHGrid</a>. <a href="https://developer.apple.com/documentation/swiftui/lazyvgrid">LazyVGrid</a> is used for creating vertical grids and <a href="https://developer.apple.com/documentation/swiftui/lazyhgrid">LazyHGrid</a> is used for horizontal grids. The keyword <strong>Lazy</strong> means that the grids view does not create items for the grid until they are needed to appear on screen. This allows our app to have much faster loading times when using grids!</p><p>In this post we are going to look at how to make a¬†<strong>LazyVGrid</strong>. All the examples in this post can be applied to <strong>LazyHGrid</strong>.</p><p>There are three things we need to make a <strong>LazyVGrid</strong>.</p><ol><li>We need a list of data to display</li><li>We need a <strong>GridItem</strong>. This defines how we want the layout to look</li><li>We need to choose if we want our grid to be vertical or horizontal</li></ol><p>private var gridLayout = [ GridItem(.flexible()), GridItem(.flexible()) ]</p><p>Above we are creating the <strong>gridLayout</strong> variable which is an array of <strong>GridItem</strong>'s. We will use this variable to set the layout we want for our grid. Later we will talk about the <strong>.flexible()</strong> but for now don't worry.</p><p>In this example we want two columns in our grid. The more <strong>GridItem</strong>'s we add to the array will mean more columns of our data to be displayed on the screen. We can add as many columns as our display can handle but for this example we are going to use two columns.</p><p>Next we need to add a <strong>ScrollView</strong> and our <strong>LazyVGrid</strong>.</p><p>private var gridLayout = [ GridItem(.flexible()), GridItem(.flexible()) ]<br> var body: some View {<br> ScrollView { LazyVGrid(columns: gridLayout, spacing: 20) { ForEach((1...100), id: .self) { Text("($0)") .font(.title) .foregroundColor(Color.white) .frame(minWidth: 0, maxWidth: .infinity, minHeight: 50) .background(Color.red) } } .padding(.all, 10) } }</p><p>In the above code we are applying our <strong>gridLayout</strong> variable to our <strong>LazyVGrid</strong> with a spacing of 20. Then we are adding a ForEach statement that will display numbers in a text view from 1 to 100 and we added a little styling to the text view.</p><p>Now if we run the code above we should get two columns of numbers in a vertical grid like in the image below.</p><img src="https://swifttom.com/wp-content/uploads/2020/07/screen-shot-2020-07-31-at-5.34.42-pm.png?w=541"/><p>In the above example we used the <strong>flexible</strong> lazy grid style. This <strong>flexible</strong> style allows us to specify how big we want each item to be and also lets us control of how many columns we want to display. There are two other types of grid styles called <strong>fixed</strong> and <strong>adaptive</strong>.</p><p>The <strong>fixed</strong> grid type will make any of our column's fixed to a particular width size. To show this in an example we are going to run the same code as above but switch our first <strong>GridItem</strong> style.</p><p>private var gridLayout = [ GridItem(.fixed(100)), GridItem(.flexible()) ]</p><img src="https://swifttom.com/wp-content/uploads/2020/08/screen-shot-2020-08-02-at-2.48.36-pm.png?w=588"/><p>You can now see that our first <strong>GridItem</strong> in our grid will always have a <strong>fixed</strong> width of 100, while the <strong>flexible</strong> style on the second <strong>GridItem</strong> will take up the rest of the row space.</p><p>Next we have the <strong>adaptive</strong> grid layout which will take a minimum width and display as many rows as it can on the screens layout.</p><p>private var gridLayout = [ GridItem(.adaptive(minimum: 100)), ]</p><img src="https://swifttom.com/wp-content/uploads/2020/08/screen-shot-2020-08-02-at-2.53.55-pm.png?w=549"/><p>All of these same methods for customizing <strong>LazyVGrid</strong> can be used when creating <strong>LazyHGrid</strong>. A reminder you can only use this style of lazy grids in apps supporting iOS 14 and above.</p><p>Hope this helps you to be more lazy with your grids!</p><p>üò¥üõå Happy Coding üò¥üõå</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-07-20-how-to-detect-dark-mode-in-swiftui</guid><title>"How to Detect Dark Mode in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-07-20-how-to-detect-dark-mode-in-swiftui</link><pubDate>Mon, 20 Jul 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>How to Detect Dark Mode in SwiftUI</h1><p>SwiftUI makes it really simply to detect when dark mode is enabled. We simply have to add a <strong>@Enviroment</strong> variable and use <strong>.colorScheme</strong> property to scan the settings on our device and see if dark mode is enabled.</p><p>Let's take a look at the example below.</p><p>struct ContentView: View { @Environment(.colorScheme) var colorScheme</p><p>var body: some View { ZStack { Color(colorScheme == .light ? .blue : .red) Text("Hello, World!") } } }</p><p>In the code above we are creating the <strong>@Environment</strong> variable to see if our device is in dark mode. Then inside of our body view we are setting the background color to red if its in dark mode or blue if its not in dark mode by using our <strong>colorScheme</strong> variable inside of a <a href="http://swifttom.com/2020/04/01/what-is-a-ternary-operator-in-swift/">ternary operator</a>.</p><p>A great use case for this is if you want to support different custom UI's for when the users device is in dark mode.</p><p>üåÉ Happy Coding! üåÉ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-07-13-how-to-set-an-image-as-a-watchos-complication</guid><title>"How to Set an Image as a WatchOS Complication"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-07-13-how-to-set-an-image-as-a-watchos-complication</link><pubDate>Mon, 13 Jul 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>How to Set an Image as a WatchOS Complication</h1><p>The reason I'm writing this post is because I had submitted a WatchOS side project I was working on (<a href="https://apps.apple.com/us/app/status-of-github/id1493860473">Status of Github)</a> to the app store. The problem was that I submitted the app with all complications activated but had no image or placeholders for the complications (How embarrassing ü§¶üèª‚Äç‚ôÇÔ∏è). So let's jump into the project and fix this issue by setting a image to our complications.</p><p>Let's get started by going into the WatchOS project folder at the top of our file navigation.</p><p>We need to select the <strong>General</strong> tab at the top and then scroll down to the <strong>Complication Configuration</strong> section.</p><p>Next we will select which complications we want to support for our project.</p><img src="https://swifttom.com/wp-content/uploads/2020/07/screen-shot-2020-07-10-at-5.56.07-pm.png?w=1024"/><p>Now we will need to add the image we want to use to the <strong>Assets</strong> folder in the <strong>WatchKit Extension</strong> part of our WatchOS app.</p><img src="https://swifttom.com/wp-content/uploads/2020/07/screen-shot-2020-07-10-at-5.52.12-pm.png?w=528"/><p>In the <strong>Assets</strong> folder you will see another folder named <strong>Complication</strong>.</p><img src="https://swifttom.com/wp-content/uploads/2020/07/screen-shot-2020-07-10-at-6.06.01-pm.png?w=1024"/><p>In this folder we will add the image that we want to show for the complication types we chose to support in the <strong>Complication Configuration</strong>.</p><p>I would recommend checking out Apple's <a href="https://developer.apple.com/design/human-interface-guidelines/watchos/overview/complications/">Human Interface Guidelines</a> to get the right dimensions for each complication so we have the right size image to display.</p><p>Now we will move on to the <strong>Complication Controller</strong> file where we will set the image from our assets folder to our complications.</p><img src="https://swifttom.com/wp-content/uploads/2020/07/screen-shot-2020-07-10-at-6.10.35-pm.png?w=1024"/><p>func getCurrentTimelineEntry(for complication: CLKComplication, withHandler handler: @escaping (CLKComplicationTimelineEntry?) -&gt; Void) { // Call the handler with the current timeline entry</p><p>if complication.family == .circularSmall { let template = CLKComplicationTemplateCircularSmallRingImage() guard let image = UIImage(named: "Complication/Circular") else { handler(nil); return} template.imageProvider = CLKImageProvider(onePieceImage: image) let timelineEntry = CLKComplicationTimelineEntry(date: Date(), complicationTemplate: template) handler(timelineEntry)<br> } else if complication.family == .utilitarianSmall { let template = CLKComplicationTemplateUtilitarianSmallRingImage() guard let image = UIImage(named: "Complication/Utilitarian") else { handler(nil); return} template.imageProvider = CLKImageProvider(onePieceImage: image) let timelineEntry = CLKComplicationTimelineEntry(date: Date(), complicationTemplate: template) handler(timelineEntry)<br> } else if complication.family == .modularSmall { let template = CLKComplicationTemplateModularSmallRingImage() guard let image = UIImage(named: "Complication/Modular") else { handler(nil); return} template.imageProvider = CLKImageProvider(onePieceImage: image) let timelineEntry = CLKComplicationTimelineEntry(date: Date(), complicationTemplate: template) handler(timelineEntry)<br> } else if complication.family == .graphicCircular { let template = CLKComplicationTemplateGraphicCircularImage() guard let image = UIImage(named: "Complication/GraphicCircular") else { handler(nil); return} template.imageProvider = CLKFullColorImageProvider(fullColorImage: image) let timelineEntry = CLKComplicationTimelineEntry(date: Date(), complicationTemplate: template) handler(timelineEntry)<br> } else if complication.family == .graphicCorner { let template = CLKComplicationTemplateGraphicCornerCircularImage() guard let image = UIImage(named: "GraphicCorner") else { handler(nil); return} template.imageProvider = CLKFullColorImageProvider(fullColorImage: image) let timelineEntry = CLKComplicationTimelineEntry(date: Date(), complicationTemplate: template) handler(timelineEntry)</p><p>} else { handler(nil) }</p><p>}</p><p>In the code above we created a image template for each of the complications. Then we set our image to the template. Lastly we set our temple to a complication timeline entry so that it can be displayed to the watch face.</p><p>Now let's run our code in the simulator and go to the watch face home screen.</p><p>Here we can press and hold on the screen to customize the watch face and set our new complication.</p><p>Now that our complication is on our watch face, we can simply tap on our complication and we will be take directly into our app!</p><img src="https://swifttom.com/wp-content/uploads/2020/07/simulator-screen-shot-apple-watch-series-5-44mm-2020-07-11-at-17.26.27.png?w=368"/><p>I hope this helps you from making the same mistake I made!</p><p>If you want to learn more about complications in WatchOS I highly recommend checking out this WWDC15 video called <a href="https://developer.apple.com/videos/play/wwdc2015/209/">Creating Complications with ClockKit</a>.</p><p>‚åöÔ∏è Happy Coding! ‚åöÔ∏è</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-07-08-disclosure-groups-in-swiftui</guid><title>"Disclosure Groups in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-07-08-disclosure-groups-in-swiftui</link><pubDate>Wed, 8 Jul 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>Disclosure Groups in SwiftUI</h1><p>At WWDC 2020 disclosure groups were announced for SwiftUI. Disclosure groups are very similar to how drop down menus work on the Mac. <a href="https://developer.apple.com/documentation/swiftui/disclosuregroup">Apple's documentation</a> defines it as "A view that shows or hides another content view, based on the state of a disclosure control".</p><p>Before we get started on building a disclosure group you will need to have Xcode 12 installed and be running your project for iOS 14 or newer.</p><p>In this post we will be using disclosure groups to help us build parts of a settings menu in a app.</p><p>Let's open a new SwiftUI project in Xcode and get started.</p><p>The first thing we will need for our disclosure group is a @State variable so we can keep track of if our disclosure view is expanded or not.</p><p>@State private var isSettingsExpanded: Bool = false</p><p>Next we need to add our disclosure group to our body view.</p><p>@State private var isSettingsExpanded: Bool = false<br>var body: some View { DisclosureGroup("Settings", isExpanded: $isSettingsExpanded) { Text("Terms of service") } .padding() }</p><img src="https://swifttom.com/wp-content/uploads/2020/07/screen-shot-2020-07-08-at-2.30.44-pm.png?w=531"/><p>If we go and run this code you should see a disclosure group labeled "Settings" and if we tap on the arrow we should see a drop down that has our "Terms of Service" text view.</p><p>What's really cool is that we can nest Disclosure groups as well.</p><p>@State private var isSettingsExpanded: Bool = false @State private var isTermsOfServiceExpanded: Bool = false</p><p>var body: some View { DisclosureGroup("Settings", isExpanded: $isSettingsExpanded) { DisclosureGroup("Terms of Service", isExpanded: $isTermsOfServiceExpanded) { Text("NO ONE READS THESE THINGS!") } } .padding() }</p><img src="https://swifttom.com/wp-content/uploads/2020/07/screen-shot-2020-07-08-at-2.28.45-pm.png?w=558"/><p>Above we added another state property and a disclosure group like we did before. Now we have our "Terms of Service" disclosure view nested to our parent "Settings" disclosure view.</p><p>We also are not limited to just using text, we can also use any kind of view in our disclosure group. For example maybe we want to turn on and off dark mode in our app. We can simply add a toggle to our disclosure group.</p><p>@State private var isDarkModeOn = true @State private var isSettingsExpanded: Bool = true</p><p>var body: some View { DisclosureGroup("Settings", isExpanded: $isSettingsExpanded) { Toggle("Dark Mode", isOn: $isDarkModeOn) } .padding() }</p><img src="https://swifttom.com/wp-content/uploads/2020/07/screen-shot-2020-07-08-at-2.32.12-pm.png?w=543"/><p>With just a few lines of code we can have all kinds of information being displayed or hidden from the user.</p><p>I hope this brief look into disclosure groups helps you to build amazing SwiftUI apps!</p><p>Happy Coding!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-07-01-how-to-style-an-image-in-swiftui</guid><title>"How to Style an Image in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-07-01-how-to-style-an-image-in-swiftui</link><pubDate>Wed, 1 Jul 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>How to Style an Image in SwiftUI</h1><p>In this post we are going to take a look at how to customize images in SwiftUI.</p><p>First thing we need to do is open a new SwiftUI Xcode project and add an image to our assets folder. I downloaded a random image of a husky as my image asset but feel free to use any image you would like.</p><p>Next we will set our image in our <strong>ContentView.swift</strong> file like the example below.</p><p>struct ContentView: View { var body: some View { Image("husky") } }</p><p>Now that we have our image set let us customize it so that it fits our screen better. We can start by resizing our image using the <strong>.resizeable()</strong> modifier.</p><p>struct ContentView: View { var body: some View { Image("husky") .resizable() } }</p><img src="https://swifttom.com/wp-content/uploads/2020/06/screen-shot-2020-06-30-at-5.07.23-pm.png?w=574"/><p>Now the image fits the screen but we definitely want the image to look a little less crammed on screen. We can fix this by adding the <strong>.scaledToFit()</strong> modifier. This allows the image to fit the screen without making the image look crammed.</p><p>struct ContentView: View { var body: some View { Image("husky") .resizable() .scaledToFit() } }</p><img src="https://swifttom.com/wp-content/uploads/2020/06/screen-shot-2020-06-30-at-5.09.20-pm.png?w=562"/><p>We can also resize the frame of our image by add the <strong>.frame()</strong> modifier.</p><p>struct ContentView: View { var body: some View { Image("husky") .resizable() .scaledToFit() .frame(width: 300.0, height: 300.0) } }</p><img src="https://swifttom.com/wp-content/uploads/2020/06/screen-shot-2020-06-30-at-5.13.39-pm.png?w=552"/><p>We can also clip our image into a shape. In this example we are going to clip out image into a circular shape like how many apps show profile pictures. SwiftUI makes this real easy by adding the <strong>.clipShape(Circle())</strong> modifier.</p><p>struct ContentView: View { var body: some View { Image("husky") .resizable() .scaledToFit() .clipShape(Circle()) } }</p><img src="https://swifttom.com/wp-content/uploads/2020/06/screen-shot-2020-06-30-at-5.23.18-pm.png?w=553"/><p>These are some of the ways we can manipulate images in SwiftUI.</p><p>As a recap we learned how to use <strong>.resizeable()</strong> modifier which allows us to resize the aspect ratio of the image. We also used <strong>.aspectRatio()</strong> or the <strong>.scaledToFit()</strong> modifier to fill the content of our image so it will look proper on screen. Lastly we learned how to resize the frame of an image and saw how we can clip images into shapes like we did with the circle image.</p><p>I hope this helps to show how powerful and easy it is to customize images in SwiftUI.</p><p>üì∑üåâ Happy Coding!! üåâüì∑</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-06-19-how-to-customize-text-in-swiftui</guid><title>"How to Customize Text in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-06-19-how-to-customize-text-in-swiftui</link><pubDate>Fri, 19 Jun 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>How to Customize Text in SwiftUI</h1><p>In this post we are going to take a quick look at how to style text in SwiftUI.</p><p>If we want to change the font of our text we can simply add the <strong>.font</strong> modifier.</p><img src="https://swifttom.com/wp-content/uploads/2020/06/screen-shot-2020-06-14-at-1.51.43-pm.png?w=1024"/><p>Above you can see Swift has preset options of font types like <strong>title</strong>, <strong>body</strong>, <strong>large title</strong> and many more. We also have the option of using our own custom fonts like the example below.</p><img src="https://swifttom.com/wp-content/uploads/2020/06/screen-shot-2020-06-14-at-1.54.55-pm.png?w=854"/><p>.font(.custom("Helvetica", size: 15))</p><p>Let's say we want to change the thickness or thinness of our text. We can do this by using the <strong>.fontWeight()</strong> modifier.</p><img src="https://swifttom.com/wp-content/uploads/2020/06/screen-shot-2020-06-14-at-4.42.44-pm.png?w=778"/><p>We can also change the color of the font by simply using <strong>.foregroundColor()</strong> modifier. This allows us to select the color of our text lettering.</p><p>You can also change the background color of the text view by using <strong>.backgroundColor()</strong> modifier.</p><p>Text("Warning") .background(Color.red) .foregroundColor(.white)</p><p>Lastly we can also change how far the spacing is between multiple lines by using <strong>.lineSpacing</strong> and <strong>.lineLimit</strong>.</p><p>The <strong>.lineSpacing</strong> modifier allows us to make the lines shorter or longer between line breaks and the <strong>.lineLimit</strong> modifier allows us to limit the lines in a text view.</p><p>.lineLimit(3) .lineSpacing(10)</p><p>These are the basics on how to manipulate text so we can customize them to our liking.</p><p>I hope this helps you to better understand how to customize text in SwiftUI.</p><p>üë®üèª‚Äçüíªüíª Happy Coding!! üë®üèª‚Äçüíªüíª</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-05-30-what-is-escaping-and-nonescaping-in-a-swift-closure</guid><title>"What is @escaping and @nonescaping in a Swift closure?"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-05-30-what-is-escaping-and-nonescaping-in-a-swift-closure</link><pubDate>Sat, 30 May 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>What is @escaping and @nonescaping in a Swift closure?</h1><p>A Closure is a block of code that can pass around data. Closure's are similar to functions but have special attributes. One feature of what makes closure's special is that the block of code inside the closure can live passed the function they are called in. It does this by retaining a copy of the closures code in memory until it finishes executing. More about that in a bit, let's look at an example of a simple closure below.</p><p>let greetingClosure = { (name:String) -&gt; String in<br> return "Hello (name)!"<br><br>}<br><br>let message = greetingClosure("Swift Tom")<br><br>print(message)</p><p>// Output: Hello Swift Tom!</p><p>In the example above we have a closure variable that takes in a parameter and returns a string. When the example above is called its value is assigned to our closure variable and then printed out.</p><p>Now that we have seen a basic closure let's look at when to use <strong>@escaping</strong> and <strong>@nonescaping</strong> in a closure.</p><p>A common example of a <strong>@escaping</strong> closure would be a completion handler. Completion handlers run asynchronous tasks like a network call. Let's look a example of a network call below.</p><p>func performRequest(parameters: [String: String], completionHandler: @escaping (Result<Data, Error>) -> Void) {
   
 var request = URLRequest(url: url)
    request.httpMethod = "GET"
    request.setValue("application/json", forHTTPHeaderField: "Content-Type")
    request.httpBody = try! JSONEncoder().encode(parameters)

    let task = URLSession.shared.dataTask(with: request) { data, \_, error in
        guard let data = data else {
            completionHandler(.failure(error!))
            return
        }
        completionHandler(.success(data))
    }
    task.resume()
}

The **@escaping** allows for the closure to be retained in memory until the completion handler either returns success on the network call or a failure. The **@escaping** outlives the function it was created in to retrive the data we are requesting.

A **@nonescaping** closure is the opposite of **@escaping** and doesn't live past the function it was called in. Below is an example of a **@nonescaping** closure.

func calculateSumOf(array:\[Int\],  handler: ((Int)->Void)) {  
        var sum: Int = 0  
        for value in array {  
            sum += value  
        }  
            handler(sum)  
    }  

func getSum() {  
        self.calculateSumOf(array: \[22, 18, 9, 50\]) { \[weak self\] sum in  
        
        print(sum)  
        // finishing the execution  
        }  
    } 

getSum()
//Output: 99

In the above example we can see that the function getSum( ) will calculate the sum of the values passed into the array. Once the function finishes running the closure will not be retained memory.

All closures by default are **@nonescaping** closure‚Äôs. The first example I used in this post is also a **@nonescaping** closure.

The reason for all closures being **@nonescaping** by default is performance and code optimization for the compiler. If the compiler knows that the closure is **@nonescaping** it can manage the memory allocation in the closure much faster because it doesn't have to retain memory until it is returned like in a **@escaping** closure.

If you want to learn more about closures and how to use them checkout the excellent Swift documentation on [closures](https://docs.swift.org/swift-book/LanguageGuide/Closures.html).

Hope this helps to explain escaping and non-escaping closure.

‚êõ Happy Coding üö´‚êõ
</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-05-24-what-are-optionals-in-swift</guid><title>"What are Optionals in Swift"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-05-24-what-are-optionals-in-swift</link><pubDate>Sun, 24 May 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>What are Optionals in Swift</h1><p>A optional in Swift is the handling of <strong>nil</strong> in a variable. We check to see if our value is <strong>nil</strong> by a process we call unwrapping. Similar to a box that came in the mail, we have no idea if the box has anything inside or if it has <strong>nil</strong> inside. The only way to find out is by unwrapping it. Let's look at a example to see how we can handle unwrapping optionals.</p><p>import UIKit</p><p>var studentScores: [Int] = [81, 77, 65, 93, 55] studentScores.sort()</p><p>// if let if let topScore = studentScores.last { // If topScore has a value print("The top score in the class is (topScore)") } else { // If nil print("There are no student scores") }</p><p>// guard let func getTopScore() { // If topScore is nil break out of the function guard let topScore = studentScores.last else { return } print(topScore) }</p><p>// nil coalescing // allows us to set a default value of the same type if nil let topScore = studentScores.last ?? 100</p><p>// force unwrap let highestScore = studentScores.last!</p><p>In the above example we are trying to see what the students top score was in the class. Let's pretend that we don't know if the <strong>studentScores</strong> array is nil. In the example we use the 4 main ways to handle unwrapping optionals in Swift.</p><p>The first way we handle an optional value is by using a <strong>if let statement</strong>. A <strong>if let statement</strong> allows us to check the variable and then handle the value in a <strong>if else statement</strong>.</p><p>The second way is using a <strong>guard let statement</strong>. A <strong>guard let statement</strong> can only be used inside of a function. This way of checking an optional is like a line in the sand because if the <strong>guard let statement</strong> finds that the variable is <strong>nil</strong> it will no longer run the code inside of the function.</p><p>The third method of unwrapping is called <strong>nil coalescing</strong>. This allows us to set a default value of the same type if the value is nil.</p><p>Our last way of unwrapping an optional is by force unwrapping. This is dangerous to do because if the value turns out to be nil your app will crash. You should only force unwrap if you know the value can never be nil.</p><p>Hope this helps you to better understand optionals in Swift.</p><p>üë®üèª‚Äçüíª Happy Programming! üë®üèª‚Äçüíª</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-05-21-what-are-life-cycle-functions-in-swiftui</guid><title>"What are Life Cycle Functions in SwiftUI?"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-05-21-what-are-life-cycle-functions-in-swiftui</link><pubDate>Thu, 21 May 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>What are Life Cycle Functions in SwiftUI?</h1><p>If you have done any development with UIKit you have used a life cycle function. These UIKit life cycle functions would be <strong>viewDidLoad</strong>, <strong>viewWillAppear</strong>, <strong>viewWillDisappear</strong>, and <strong>viewDidDisappear</strong>. In SwiftUI we lose these life cycle functions because there are no more ViewControllers in SwiftUI, only views. SwiftUI replaces these functions with two methods called <strong>onAppear( )</strong> and <strong>onDisappear( )</strong>.</p><p><strong>onAppear( ):</strong> is a function that runs every time a view appears on screen. The <strong>onAppear( )</strong> function is similar to the <strong>viewWillAppear</strong> function used in UIKit. A good example of how we can use the <strong>onAppear( )</strong> function is for any network calls we would need for that view.</p><p><strong>onDisappear( ):</strong> is a function that runs when a view disappears from our apps screen. This function is similar to the <strong>viewWillDisappear</strong> function in UIKit. A example for when to use the <strong>onDisappear( )</strong> function is for clearing any data before dismissing that view.</p><p>By using the <a href="https://developer.apple.com/documentation/swiftui/text/3276931-onappear"><strong>onAppear(</strong></a> <strong>)</strong> and <strong><a href="https://developer.apple.com/documentation/swiftui/text/3276933-ondisappear">onDisappear( )</a></strong> functions in SwiftUI we can achieve similar behavior and functionality to the UIKit lifecycle functions.</p><p>Thanks for reading and I hope this helps in your learning of SwiftUI!</p><p>üë®üèª‚Äçüíª Happy Programming üë®üèª‚Äçüíª</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-05-21-what-are-life-cycle-methods-in-swift</guid><title>"What are Life Cycle Methods in Swift"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-05-21-what-are-life-cycle-methods-in-swift</link><pubDate>Thu, 21 May 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>What are Life Cycle Methods in Swift</h1><p>In Swift our view controllers have life cycle methods. Knowing your apps life cycle is really important for developers to understand how there app works. In this post we are going to run through all the life cycle methods we should know about when developing in iOS.</p><p><strong>loadView:</strong> This method loads or creates a view and assigns it to the¬†<code>[view](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621460-view)</code>¬†property<em>.</em> This method is most commonly used if you are creating your view controllers programmatically.</p><p><strong>viewDidLoad:</strong> This is called one time in a view controllers life cycle when the view controller is initially created. It gets called when the content view is created in memory. Some common use cases for this method would be to make network calls, set up user interface, or anything that needs to be called once when the view has been loaded.</p><p><strong>viewWillAppear:</strong> This is called before the content view is added to the view hierarchy in your app. This means that this is called just before the view shows up on screen. This method will also be called every time the view is going to appear on screen. This is the main difference between viewDidLoad. You can override viewWillAppear to display custom views and animation like hiding fields or disable actions before the view is visible to the user.</p><p><strong>viewDidAppear:</strong> This is called right after the view appears on screen. This method is good to use for taking care of things like saving data to core data or starting animations.</p><p><strong>viewWillDisappear:</strong> This is called right before the view is removed from the screen. Things that are usually handled in this method are saving changes in the app. A example of this is having a form for the user to sign up to your app. Let's imagine our user was half way done filling out the form and then the user leaves the app. In viewWillDisappear we can save the users inputs before leaving the app so progress isn't lost.</p><p><strong>viewDidDisappear:</strong> This is called after all view controllers views have been removed from the view hierarchy. We can use this to stop listening to device sensors or stop listening for any notifications.</p><p><strong>viewWillLayoutSubviews:</strong> This is called when the content views bounds change but before it lays out its subviews. A example of this is when the bounds change when we rotate the device from portrait to landscape. This always us to layout any customization before the rotation happens.</p><p><strong>viewDidLayoutSubviews:</strong> Similar to <strong>viewWillLayoutSubviews</strong>, this method is called when the content views bounds change but after it lays out its subviews.</p><p>These are the main life cycle method you should know when programming in swift. Knowing when and how to use these methods can help in solving error for when the app should do a particular task. Below is an image for you to try and visualize the flow of the life cycle methods when being used in an app.</p><img src="https://tprezioso.github.io//images/167c0-https3a2f2fcdn-images-1.medium.com2fmax2f16002f1jb1y17gwqcri2xcky7_qhq.png"/><p>I hope this helps to shed some light on how and when to use a particular life cycle method in swift.</p><p>üö¥‚Äç‚ôÇÔ∏è Happy coding üö¥‚Äç‚ôÇÔ∏è</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-05-12-variadic-functions-in-swift</guid><title>"Variadic Functions in Swift"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-05-12-variadic-functions-in-swift</link><pubDate>Tue, 12 May 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>Variadic Functions in Swift</h1><p>What is a variadic function? A <strong>Variadic function</strong> takes in¬†multiple arguments as a parameter. The swift compiler automatically organizes variadic function objects into an array. The arguments of a variadic function are shown by three periods¬†<strong>(‚Ä¶</strong>) after the argument‚Äôs type. A good everyday example of this would be a print statement where you can print multiple objects.</p><img src="https://swifttom.com/wp-content/uploads/2020/05/screen-shot-2020-05-09-at-10.43.03-am.png?w=746"/><p>The <strong>"Any..."</strong> in the autocomplete of our print statement shows a variadic function allowing us to print multiple objects.</p><img src="https://swifttom.com/wp-content/uploads/2020/05/screen-shot-2020-05-09-at-12.43.18-pm.png?w=778"/><p>Below is another example on how to use a variadic function inside of a function.</p><p>func average(_ numbers: Double...) -&gt; Double { var total: Double = 0 for number in numbers { total += number } return total / Double(numbers.count) } average(1, 2, 3, 4, 5) // Output: 3</p><p>Above we have a function that finds the average of our <strong>numbers</strong> parameter. The <strong>numbers</strong> parameter is our variadic function, it will take in as many numbers as we want and then use them in an array to calculate the average.</p><p>I hope this clears up how a variadic function work!</p><p>Happy coding!</p><p>üë®üèª‚Äçüíªüíªüì±üë®üèª‚Äçüíªüíªüì±</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-04-27-what-is-arc-memory-management-in-swift</guid><title>"What is ARC memory management in Swift"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-04-27-what-is-arc-memory-management-in-swift</link><pubDate>Mon, 27 Apr 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>What is ARC memory management in Swift</h1><p>What is <strong>ARC</strong>? <strong>ARC</strong> stands for <strong>Automatic Reference Counting</strong>. Reference counting is a way of storing number references or pointer to a object. In short <strong>ARC</strong> helps to store references into memory and helps clean up memory when it is not being used.</p><p>Apples documentation says ‚ÄúMemory management ‚Äújust works‚Äù in Swift, and you do not need to think about memory management yourself. <strong>ARC</strong> automatically frees up the memory used by class instances when those instances are no longer needed.‚Äù</p><p><strong>ARC</strong> uses references like <strong>strong</strong>, <strong>weak</strong>, or <strong>unowned</strong> as a way of knowing when to free memory for a given object. By default when we declare a class property its a <strong>strong</strong> reference type. In this post we will take a look at how to use <strong>strong</strong> and <strong>weak</strong> references in <strong>ARC</strong>.</p><p>Let‚Äôs take a look at the example code below.</p><p>class Person { var name: String var device: Device? init(name: String, device: Device?) { self.name = name self.device = device } }</p><p>class Device { var owner: Person? var device: String init(owner: Person, device: String) { self.owner = owner self.device = device } }</p><p>In the above example we created two classes, a <strong>Person</strong> class and a <strong>Device</strong> class. We created these classes to show an example of a <strong>strong</strong> reference cycle.</p><p>The <strong>Person</strong> class¬†has a <strong>strong</strong> reference to the¬†<strong></strong>Device<strong></strong> class¬†through it‚Äôs¬†<strong></strong>device<strong></strong>¬†property, and¬†<strong></strong>device<strong></strong>¬†has a <strong>strong</strong> reference to¬†<strong>Person</strong>¬†through its¬†<strong>owner</strong>¬†property. The problem with this is that these objects hold <strong>strong</strong> references to one another. This means that <strong>ARC</strong> is unable to deallocate memory when one of the objects are removed because they reference one another. This creates a memory leak in our code.</p><p>To fix our <strong>strong</strong> reference cycle problem we will have to set our <strong>device</strong> variable to a <strong>weak</strong> variable type in our <strong>Person</strong> class. This allows the variable to be deallocated from memory when its not need.</p><p>class Person { var name: String weak var device: Device? init(name: String, device: Device?) { self.name = name self.device = device } }</p><p>class Device { var owner: Person? var device: String init(owner: Person, device: String) { self.owner = owner self.device = device } }</p><p>Above we now have the¬†<strong>Device</strong>¬†class with a <strong>strong</strong> reference to the¬†<strong>Person</strong>¬†class, but the¬†<strong>Person</strong>¬†class has a <strong>weak</strong> reference to the¬†<strong>Device</strong>¬†class.</p><p>When we use a <strong>weak</strong> reference type on a object it needs to be a optional because it has to have the ability to become nil. If the¬†<strong>Device</strong> class variable¬†becomes nil our¬†<strong>Person</strong>¬†class will deallocate or release the memory stored. This corrects our <strong>strong</strong> reference cycle and stops our memory leak.</p><p><strong>A good rule of thumb</strong>:</p><p>A <strong>Strong</strong> references should be used when a parent object is referencing a child object.</p><p>A <strong>Weak</strong>¬†references should be used to avoid retain cycles.</p><p>This is a brief look at how <strong>ARC</strong> memory management works. For a deeper dive into <strong>ARC</strong> I recommending checking out the Swift documentation on <a href="https://bit.ly/2L94na0">Automatic Reference Counting</a>.</p><p>I hope this opened the curtain to what goes on behind the scenes of Swift memory management and helps to shed some light on how <strong>ARC</strong> works in Swift.</p><p>üë®üèª‚Äçüíª Happy Programming! üë®üèª‚Äçüíª</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-04-25-how-to-make-a-secure-textfield-in-swiftui</guid><title>"How to make a Secure TextField in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-04-25-how-to-make-a-secure-textfield-in-swiftui</link><pubDate>Sat, 25 Apr 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>How to make a Secure TextField in SwiftUI</h1><p>A secure textfield allows us to display a editable text area that hides the text the user inputs. In this post I will show you how easy it is to implement a secure textfield in a SwiftUI project.</p><p>First we will need to open a SwiftUI project. Next we will need to copy the code below into our ContentView.swift file</p><p>import SwiftUI</p><p>struct ContentView: View {<br> // 1. @State private var password: String = "" @State var buttonPass: String = ""<br> var body: some View { VStack(alignment: .leading) { Text("Login") .font(.headline)<br> // 2. SecureField("Enter Your Password", text: $password) .padding(.all) .background(Color(red: 239.0/255.0, green: 243.0/255.0, blue: 244.0/255.0, opacity: 1.0)) .cornerRadius(10)</p><p>// 3. HStack { Spacer() Button(action: { self.buttonPass = self.password<br> }) { Text("Login") .foregroundColor(.white) } .frame(width: 150) .padding(.all) .background(Color.green) .cornerRadius(10) Spacer() }</p><p>// 4. Text("(buttonPass)") }.padding()<br> }<br>}</p><p>So what's going on in the code above is:</p><ol><li>We are creating @State property which will represent the entered text inside the textfield. Our other @State property is for passing our password to a label once the login button is pressed.</li><li>Create a SecureField with our placeholder text.</li><li>Making a button that when tapped will display our password.</li><li>Our Text where we will display the password.</li></ol><p>Now if we go to our preview canvas and run our code you will see our login secure textfield and our login button. Type a password in and tap the login button. You should see something like the example below.</p><img src="https://swifttom.com/wp-content/uploads/2020/04/screen-shot-2020-04-26-at-6.23.43-pm.png?w=502"/><p>In just a few lines of code we now have a secure textfield to handle passwords or any other secure text in SwiftUI.</p><p>Hope this quick look at secure textfields helps to secure your project!</p><p>üëÆüèª‚Äç‚ôÇÔ∏èüö®Happy coding! üö®üëÆüèª‚Äç‚ôÇÔ∏è</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-04-23-what-is-a-enum-in-swift</guid><title>"What is a Enum in Swift"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-04-23-what-is-a-enum-in-swift</link><pubDate>Thu, 23 Apr 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>What is a Enum in Swift</h1><p>What is a Enum? Apple defines and enum as ‚Äúa common type for a group of related values and enables you to work with those values in a type-safe way within your code‚Äù. What the heck does that mean? A enum is shorthand for enumeration and gives us a way to use fixed names for values rather than using strings or integers. Let's take a look at an example to better explain how to use a enum.</p><p>enum Device { case phone case computer case tablet }</p><p>In the above example we created a enum of devices. We can uses this enum to give our code a clean way to assign a value to a object. Let's look at the example below to see how we can apply this enum to a person struct.</p><p>struct Person { var name: String var device: Device }</p><p>Above you can see we assigned our device variable to our <strong>Device enum</strong>. Because of this we now can use the <strong>Device</strong>¬†<strong>enum</strong> to specify which device we want to assign when creating our Person variable.</p><p>let person1 = Person(name: "Tom", device: .phone) let person2 = Person(name: "Tim", device: .computer) let person3 = Person(name: "Ted", device: .tablet)</p><p>Another scenario for using enum's that you will see in most app projects is when using custom error messages. Below is an example of how I setup a error messages enum in a project I am working on.</p><p>import Foundation</p><p>enum TPError : String, Error { case invalidUsername = "This username created and invalid request. Please try again" case unableToComplete = "Unable to complete your request. Please check your internet connection" case invalidResponse = "Invalid response from the server. Please try again" case invalidData = "The data received from the sever was invalid. Please try again" case unableToFavorite = "There was an error favoriting this user please try again" case alreadyInFavorites = "You already favorited this person" }</p><p>Above is my <strong>TPError.swift</strong> file which stores all my error messages in a enum to display in my app. Next let us look at an example of how I use this emun to handle error messaging in a network call.</p><p>func getFollowers(for username: String, page: Int, completed: @escaping (Result<\[Follower\], TPError>) -> Void) {
        let endpoint = baseURL + "\\(username)/followers?per\_page=100&page=\\(page)"
        
        guard let url = URL(string: endpoint) else {
            completed(.failure(.invalidUsername))
            return
        } ...

First I set my failure completion to use my **TPError**. Next in the failure completion handler I assign the **.invalidUsername** message from the enum that will be displayed on failure. This makes the code much more readable for possible future changes and eliminates a long string from being in my network call.

Using enum's is a great way to make sure you don't make silly string or value errors.

Hope this helps to explain enums and how you can use them in your swift programs!

üë®üèª‚Äçüíª Happy coding üë®üèª‚Äçüíª
</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-04-19-how-to-implement-sign-in-with-apple-in-swift</guid><title>"How to Implement Sign in with Apple in Swift"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-04-19-how-to-implement-sign-in-with-apple-in-swift</link><pubDate>Sun, 19 Apr 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>How to Implement Sign in with Apple in Swif</h1><p>At the 2019 WWDC, Apple announced Sign in with Apple which allows users to sign into applications and websites securely. Sign in with Apple ensures privacy by not tracking your sensitive information and also provides a synchronous experience across all your Apple devices. The best part is that it is offered in browsers for platforms like Android and Windows devices through Sign in with Apple JS.</p><p>Today we are going to take a look at how we can add Sign in with Apple into our swift app. Let's start by opening a new Swift project in Xcode.</p><p>First thing we have to do is enable Sign in with Apple. We do this by going to our target and going to the <strong>Signing &amp; Capabilities</strong>. Then in the left corner hit the <strong>+</strong> button and type in Sign in with Apple.</p><img src="https://swifttom.com/wp-content/uploads/2020/04/screen-shot-2020-04-14-at-4.34.53-pm.png?w=1024"/><p>Now we‚Äôre ready to add a Sign in with Apple button in our application. To implement this we need to import <strong>AuthenticationServices</strong> library and then make a <strong>ASAuthorizationAppleIDButton</strong>. Let look at the example below.</p><p>import UIKit import AuthenticationServices</p><p>class ViewController: UIViewController {</p><p>override func viewDidLoad() { super.viewDidLoad() configureSignInWithAppleButton()<br> }</p><p>func configureSignInWithAppleButton() {<br> // Create sign in button let signInButton = ASAuthorizationAppleIDButton()<br> //Add to view self.view.addSubview(signInButton)<br> // Function for the action of our button signInButton.addTarget(self, action: #selector(ViewController.signInButtonTapped), for: .touchDown)<br> // Remove constraints so we can add them programmatically signInButton.translatesAutoresizingMaskIntoConstraints = false<br> // Added button constraints NSLayoutConstraint.activate([ signInButton.centerXAnchor.constraint(equalToSystemSpacingAfter: view.centerXAnchor, multiplier: 1), signInButton.centerYAnchor.constraint(equalToSystemSpacingBelow: view.centerYAnchor, multiplier: 1), signInButton.heightAnchor.constraint(equalToConstant: 40), signInButton.widthAnchor.constraint(equalToConstant: 200) ]) } }</p><p>In the code above we are importing <strong>AuthenticationServices</strong> and then setting up our Sign in with Apple button programmatically.</p><p>First we create our button variable with our <strong>signInButton</strong>. Next we add our button to the subview. Then we add a target action to our button and remove the auto resizing constraints. Lastly we add the constraints for our sign in button.</p><p>Next we need to handle what happens when our sign in button is tapped. Let us take a look at the following code.</p><p>@objc private func signInButtonTapped() { let authorizationProvider = ASAuthorizationAppleIDProvider() let request = authorizationProvider.createRequest() request.requestedScopes = [.email]<br> let authorizationController = ASAuthorizationController(authorizationRequests: [request]) authorizationController.delegate = self authorizationController.presentationContextProvider = self authorizationController.performRequests() }</p><p>The <strong>signInButtonTapped()</strong> function will be called on when our button is tapped. What we are doing inside the function is creating our <strong>authorizationProvider</strong> and then creating a request to get the users information that we want to be able to use in our app. In this case we are only requesting for the users email but we can also ask for the users full name. Next we create a <strong>authorizationController</strong> to present to the user that will ask for permission to use their email information.</p><p>Now we need to handle the <strong>ASAuthorizationController</strong> delegate. This is where we will handle the users information once we are allowed access to the users email. To implement this we are going to add and extension at bottom of swift file outside of the viewcontroller.</p><p>extension ViewController: ASAuthorizationControllerDelegate {<br> func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) { guard let appleIDCredential = authorization.credential as? ASAuthorizationAppleIDCredential else { return }<br> print("AppleID Credential Authorization: userId: (appleIDCredential.user), email: (String(describing: appleIDCredential.email))")<br> }<br>func authorizationController(controller: ASAuthorizationController, didCompleteWithError error: Error) { print("AppleID Credential failed with error: (error.localizedDescription)") } }</p><p>In the above extension we are checking with our guard let statement to see if we have any credentials. Usually we would do something with the users information but in this case we are just going to print our user email to the console. Lastly we create a function to handle the error in case something goes wrong. We will also print out an error to the console for this example but in a real project you would want to handle the error to the user with some kind of alert view.</p><p>Lastly we need to present our <strong>ASAuthorizationController</strong> by adding another extension to <strong>ViewController</strong>.</p><p>extension ViewController: ASAuthorizationControllerPresentationContextProviding { func presentationAnchor(for controller: ASAuthorizationController) -&gt; ASPresentationAnchor { return self.view.window! } }</p><p>This allows us to present the <strong>ASAuthorizationController</strong> over our app.</p><p>Our final code should look like the example below.</p><p>import UIKit import AuthenticationServices</p><p>class ViewController: UIViewController {<br> override func viewDidLoad() { super.viewDidLoad() configureSignInWithAppleButton()<br> }</p><p>func configureSignInWithAppleButton() {<br> // Create sign in button let signInButton = ASAuthorizationAppleIDButton()<br> //Add to view self.view.addSubview(signInButton)<br> // Function for the action of our button signInButton.addTarget(self, action: #selector(ViewController.signInButtonTapped), for: .touchDown)<br> // Remove constraints so we can add them programmatically signInButton.translatesAutoresizingMaskIntoConstraints = false<br> // Added button constraints NSLayoutConstraint.activate([ signInButton.centerXAnchor.constraint(equalToSystemSpacingAfter: view.centerXAnchor, multiplier: 1), signInButton.centerYAnchor.constraint(equalToSystemSpacingBelow: view.centerYAnchor, multiplier: 1), signInButton.heightAnchor.constraint(equalToConstant: 40), signInButton.widthAnchor.constraint(equalToConstant: 200) ]) }</p><p>@objc private func signInButtonTapped() { let authorizationProvider = ASAuthorizationAppleIDProvider() let request = authorizationProvider.createRequest() request.requestedScopes = [.email]<br> let authorizationController = ASAuthorizationController(authorizationRequests: [request]) authorizationController.delegate = self authorizationController.presentationContextProvider = self authorizationController.performRequests() }<br>}</p><p>extension ViewController: ASAuthorizationControllerDelegate {<br> func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) { guard let appleIDCredential = authorization.credential as? ASAuthorizationAppleIDCredential else { return }<br> print("AppleID Credential Authorization: userId: (appleIDCredential.user), email: (String(describing: appleIDCredential.email))")<br> }<br> func authorizationController(controller: ASAuthorizationController, didCompleteWithError error: Error) { print("AppleID Credential failed with error: (error.localizedDescription)") } }</p><p>extension ViewController: ASAuthorizationControllerPresentationContextProviding { func presentationAnchor(for controller: ASAuthorizationController) -&gt; ASPresentationAnchor { return self.view.window! } }</p><p>Remember that we can only test for Sign in with Apple on a physical device and not in the Xcode simulator.</p><p>That's all there is to adding Sign in with Apple to your swift project.</p><p>I hope this post helps make it easy for your user to login to your app!</p><p>üì±üíªüë®üèª‚ÄçüíªHappy coding! üë®üèª‚Äçüíªüíªüì±</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-04-10-how-to-round-the-corners-of-a-view-in-swiftui</guid><title>"How to Round the Corners of a View in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-04-10-how-to-round-the-corners-of-a-view-in-swiftui</link><pubDate>Fri, 10 Apr 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>How to Round the Corners of a View in SwiftUI</h1><p>In this quick post we are going to look at how we can make views in SwiftUI have rounded corners. You can round the corners of any SwiftUI view by using the <strong>cornerRadius()</strong> modifier. Simply add a value to the <strong>cornerRadius</strong> to control how rounded you want the view to be. Let us look at a simple example below.</p><p>struct ContentView: View {<br> @State private var hovering = false<br> var body: some View { Button(action: {}) { Text("Button") } .buttonStyle(PlainButtonStyle()) .padding() .background(Color.green) .cornerRadius(10) } }</p><img src="https://swifttom.com/wp-content/uploads/2020/04/screen-shot-2020-04-09-at-4.38.44-pm.png?w=366"/><p>By adding a cornerRadius of 10 to our button we now get nice rounded corners on our button. This can be used on any view that you want to manipulate the corners to have rounded edges.</p><p>Hope this helps in styling your views in SwiftUI!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-04-02-adding-pointer-hover-effects-on-ipados-using-swiftui</guid><title>"Adding Pointer Hover Effects on iPadOS using SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-04-02-adding-pointer-hover-effects-on-ipados-using-swiftui</link><pubDate>Thu, 2 Apr 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>Adding Pointer Hover Effects on iPadOS using SwiftUI</h1><p>Apple's latest update now includes support for you to connect a mouse or a trackpad to your iPad in iPadOS 13.4! This is really cool but how can we implement this in our own SwiftUI app for iPad. The good news is Apple makes this simple by giving us two modifiers <strong>.hoverEffect</strong> and <strong>.onHover</strong> to add to our SwiftUI views. Let us start by opening up Xcode and in a SwiftUI project add the following code.</p><p>struct ContentView: View { var body: some View { Button(action: {}) { Text("Button") } .hoverEffect() } }</p><p>Here we created a button and added the <strong>hoverEffect</strong> modifier. By adding <strong>hoverEffect</strong> modifier we get the iPadOS hover effect that clings to the nearest view like buttons or labels. This modifier has three types of effects that we can set to the pointer. By default the <strong>hoverEffect</strong> modifier uses the first type called <strong>automatic</strong>. The other two types are <strong>highlight</strong> and <strong>lift</strong>.</p><p>.hoverEffect(.lift) .hoverEffect(.highlight)</p><p><strong>Lift</strong> is a effect that slides the pointer behind the view object and goes aways as the view scales up.</p><p><strong>Highlight</strong> is a effect that changes the pointer into a platter behind the view and shows a light source showing the cursors position.</p><p>Next we are going to look at the <strong>onHover</strong> modifier. This modifier allows us to make custom effects when the pointer hovers over a view. The <strong>onHover</strong> modifier uses a closure that is called whenever the cursor of the trackpad or mouse goes over the view. This is where we can set some state to track the cursor and implement our custom animation. Take a look at the example code below.</p><p>@State private var hovering = false<br> var body: some View { Button(action: {}) { Text("Button") } .buttonStyle(PlainButtonStyle()) .scaleEffect(hovering ? 1.5 : 1.0) .animation(.spring()) .padding() .background(Color.green) .cornerRadius(10) .onHover { isHovered in self.hovering = isHovered<br> } }</p><p>The above code created a hovering state property to keep track of if the cursor is over our button. If the cursor is hovering over our button we set the state to true in our .onHover closure. This will trigger our <strong>scaleEffect</strong> of the spring animation. This makes our text animate by enlarging it when our button has the cursor over our it.</p><p>Pretty neat!</p><p>If you have an iPad app and are using SwiftUI, definitely support the use of the trackpad and mouse in your app!</p><p>Hope this was helpful and happy coding!!</p><p>üë®üèª‚Äçüíªüñ±üë®üèª‚Äçüíªüñ±üë®üèª‚Äçüíªüñ±</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-04-01-what-is-a-ternary-operator-in-swift</guid><title>"What is a Ternary Operator in Swift"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-04-01-what-is-a-ternary-operator-in-swift</link><pubDate>Wed, 1 Apr 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>What is a Ternary Operator in Swift</h1><p>A ternary operator takes a condition and then returns either true or false depending on the value of the condition. The basic syntax can be seen in the example below.</p><p>CONDITION ? TRUE VALUE : FALSE VALUE</p><p>This can be used as an alternative or a shorthand to If statements.</p><p>Let check out an example below.</p><p>var ourSpeed = 55</p><p>var speedLimit = 50</p><p>var currentSpeed = ourSpeed &gt; speedLimit ? "Over Speed Limit" : "Below Speed Limit"</p><p>// | CONDITION | ? | TRUE | : | FALSE |</p><p>print(currentSpeed)</p><p>// OUTPUT: Over Speed Limit</p><p>You can read the ternary example above as ‚Äúif <strong>ourSpeed</strong> is greater than the <strong>speedLimit</strong> set <strong>currentSpeed</strong> to <strong>"Over Speed Limit"</strong> otherwise set <strong>currentSpeed</strong> to <strong>"Below Speed Limit"</strong>. Because our <strong>speedLimit</strong>¬†was 50, the <strong>currentSpeed</strong> variable will be set to the true value of <strong>"Over Speed Limit"</strong>.</p><p>Ternary conditionals can be a little confusing to understand at first but they can be a great way to set variables based on a condition in one line of code. This is great for writing nice clean code.</p><p>Hope this helps clear up what is/how to use ternary conditionals.</p><p>Happy coding!</p><p>üë®üèª‚Äçüíªüíªüë®üèª‚Äçüíª</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-03-27-testing-with-network-link-conditions-in-xcode</guid><title>"Testing with Network Link Conditions in Xcode"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-03-27-testing-with-network-link-conditions-in-xcode</link><pubDate>Fri, 27 Mar 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>Testing with Network Link Conditions in Xcode</h1><p>Testing how your app works in different networking conditions is really important before you release an app. As of Xcode 11, testing different network conditions built right to make our lives easier.</p><p>First thing we need to do is connect our device with Xcode. Then we need to load the app we want to test on to our device. After that we need to go to the top of the screen and click on Window drop down and then go to Devices and Simulator.</p><img src="https://swifttom.com/wp-content/uploads/2020/03/screen-shot-2020-03-22-at-10.31.57-am.png?w=1024"/><p>Next in Devices and Simulator you should see your connected device. While the app is connected and running you can now scroll down to the bottom and see device conditions.</p><img src="https://swifttom.com/wp-content/uploads/2020/03/deviceconditionsxcode.png?w=1024"/><p>In device conditions click on the profile drop down. You will see a list of networking conditions that you can use to change the networking speed.</p><p>Once you selected your networking condition you then want then press the start button. Your app will now be running at that networking speed that you have selected.</p><p>When your done testing remember to stop the device condition or else you will have poor networking on your device.</p><p>You can do this same network testing on the device itself. If you go to your iPhone/iPads settings app. Go to Developer &gt; Network Link Conditioner &gt; Enable.</p><img src="https://swifttom.com/wp-content/uploads/2020/03/img_8656.png?w=473"/><img src="https://swifttom.com/wp-content/uploads/2020/03/img_8657.png?w=473"/><p>Once enabled, you now can add a profile to test on device just like we did in Xcode.</p><p>That's all there is too it.</p><p>Happy Testing üë®üèª‚Äçüíª</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-03-19-how-to-use-switch-statements-in-swift</guid><title>"How to Use Switch Statements in Swift"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-03-19-how-to-use-switch-statements-in-swift</link><pubDate>Thu, 19 Mar 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>How to Use Switch Statements in Swift</h1><p>A switch statement is used to check a variable against a list of possible cases for that variable to then execute. It looks for the first case that matches your variable you want to check and then runs that cases block of code. When that case is finished running its code it will break out from the switch statement.</p><p>Let's look at a example.</p><p>let numberToCheck = 20</p><p>switch numberToCheck { case 0: print("0 is the number")</p><p>case 10: print("10 is the number")</p><p>case 20: print("20 is the number")</p><p>case 30: print("30 is the number")</p><p>default: print("Number is not 0, 10, 20, 30") } //OUTPUT: 20 is the number</p><p>Above is a simple example where we are checking to see the value of a number. If that number is a particular number value that matches our case we want it to print out the number of the case value. If the <strong>numberToCheck</strong> doesn't match any of the numbers in our switch case we need a <strong>default</strong> value for the <strong>numberToCheck</strong> value.</p><p>We can also have switch statements with a range.</p><p>let numberToCheck = 40</p><p>switch numberToCheck { case 0...10: print("The number is between 0 and 10")</p><p>case 10...20: print("The number is between 10 and 20")</p><p>case 20...30: print("The number is between 20 and 30")</p><p>case 30...40: print("The number is between 30 and 40")</p><p>default: print("The number is below 0 and above 40") }</p><p>//OUTPUT: The number is between 30 and 40</p><p>Above we are using our <strong>numberToCheck</strong> variable to see what print statement it should make in specific range of numbers. For example if our <strong>numberToCheck</strong> is 7 the print out would be "The number is between 0 and 10".</p><p>That's all there is too it.</p><p>Switch statements are great for checking a variable against multiple options and then being able to execute a block of code based on your variables value.</p><p>I hope this helps clean up your code from having a lot of crazy "if" statements.</p><p>üë®üèª‚Äçüíª Happy Coding üë®üèª‚Äçüíª</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-03-14-alert-views-in-swiftui</guid><title>"Alert Views in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-03-14-alert-views-in-swiftui</link><pubDate>Sat, 14 Mar 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>Alert Views in SwiftUI</h1><p>In this post we are going to take a look at how to show an alert in SwiftUI!</p><p>Implementing an alert is very simple and all we need is just a few lines of code.</p><p>Open up Xcode and create an new SwiftUI project.</p><p>In the ContentView.swift file let's creating a simple @State bool to keep track of when to show and hide our alert.</p><p>@State private var showingAlert = false</p><p>Next we will make a button and in the action part of the button we will switch the state of our <strong>showingAlert</strong> variable to true. Then we'll name the button label "Alert". Lastly we add the .alert modifier to the end of our button. In the modifier we set the state showing the alert. We also set the title, message, and dismiss button of the alert.</p><p>var body: some View { Button(action: { self.showingAlert = true }) { Text("Alert") } .alert(isPresented: $showingAlert) { Alert(title: Text("Alert"), message: Text("Something Went Wrong"), dismissButton: .default(Text("OK"))) } }</p><p>Now if we go and run this in our simulator you will see an alert button in the middle of the screen. When tapped our alert will popup with our title, message, and our dismiss button!</p><p>With minimal code we made and alert which can be used for all kinds of things in our apps.</p><p>How this helps you in learning SwiftUI!</p><p>üë®üèª‚Äçüíªüíªüë®üèª‚Äçüíªüíªüë®üèª‚Äçüíªüíªüë®üèª‚Äçüíªüíªüë®üèª‚Äçüíªüíªüë®üèª‚Äçüíªüíªüë®üèª‚Äçüíªüíªüë®üèª‚Äçüíªüíªüë®üèª‚Äçüíªüíªüë®üèª‚Äçüíªüíªüë®üèª‚Äçüíªüíªüë®üèª‚Äçüíªüíªüë®üèª‚Äçüíªüíª</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-03-11-haptic-feedback-in-a-swiftui-button</guid><title>"Haptic Feedback in a SwiftUI Button"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-03-11-haptic-feedback-in-a-swiftui-button</link><pubDate>Wed, 11 Mar 2020 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>Haptic Feedback in a SwiftUI Button</h1><p>In this post we are going to see how we can add haptic feedback to a button in SwiftUI. Apple gives us preset haptic options for us to choose from in the UINotificationFeedbackGenerator class. The haptics we can choose from are as follows:</p><ul><li>.success</li><li>.error</li><li>.warning</li><li>.light</li><li>.medium</li><li>.heavy</li><li>selectionChanged()</li></ul><p><em>NOTE: You will need to run this code on a iPhone otherwise you will not be able to feel the different vibrations.</em></p><p>Let's start out by opening a new Xcode project and go to our contentView.swift file.</p><p>First thing is we will need to create a UINotificationFeedbackGenerator called generator.</p><p>let generator = UINotificationFeedbackGenerator()</p><p>Next replace the default "Hello World" text label with a button. In the action section of the button we are going to set our feedback generator. Lastly we will add some text to the button label that just says "Success".</p><p>Button(action: { self.generator.notificationOccurred(.success) }) { Text("Success") }</p><p>Now if we run this on our iPhone you will see a button in the middle of the screen that says "Success". If you tap the Success button you will feel the success haptic vibration feedback.</p><p>Awesome!!</p><p>Now let us test out the rest of the different haptic vibrations. Let's add our success button to a VStack and add the following code.</p><p>VStack(alignment: .center, spacing: 30.0) { Button(action: { self.generator.notificationOccurred(.success) }) { Text("Success") }<br> Button(action: { self.generator.notificationOccurred(.error) }) { Text("Error") }<br> Button(action: { self.generator.notificationOccurred(.warning) }) { Text("Warning") }<br> Button(action: { let impactLight = UIImpactFeedbackGenerator(style: .light) impactLight.impactOccurred() }) { Text("Light") }<br> Button(action: { let impactMed = UIImpactFeedbackGenerator(style: .medium) impactMed.impactOccurred() }) { Text("Medium") }<br> Button(action: { let impactHeavy = UIImpactFeedbackGenerator(style: .heavy) impactHeavy.impactOccurred() }) { Text("Heavy") }<br> Button(action: { let selectionFeedback = UISelectionFeedbackGenerator() selectionFeedback.selectionChanged() }) { Text("Selection Feedback Changed") } } .padding(.all, 30.0) }</p><p>Now if you run this code on your device you will get a list of buttons that we can tap through to see the different haptic feedbacks we can use!</p><p>For a little bit of a deeper dive check out this <a href="http://bit.ly/2IDOWW7">article</a>. It helped me research this post and also thanks to Harry Harrison's gist that I found on Github. I used and edited his gist to demonstrate this article. Here is the full code in my fork of the <a href="http://bit.ly/2IGtZdg">gist</a>.</p><p>Hope this helps shake up your next coding project! üòÖ</p><p>Happy Swift Coding!</p><p>üë®üèª‚Äçüíªüíª</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-03-08-integrating-mapkit-with-swiftui</guid><title>"Integrating MapKit with SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-03-08-integrating-mapkit-with-swiftui</link><pubDate>Sun, 8 Mar 2020 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>Integrating MapKit with SwiftUI</h1><p>In this article we are going to make a simple map in SwiftUI. This map will show the users location and show how we can set pins (annotations) on our map.</p><p>Let's get started by opening a new Xcode project and adding a new SwiftUI file to our project named MapView.swift.</p><p>The first thing we are going to want to do is import MapKit and conform our struct to the UIViewRepresentable delegate.</p><p>import MapKit import SwiftUI struct MapView: UIViewRepresentable {<br>}</p><p>Next we are going to add the CLLocationManager to get our users location and set up our location manager. Add the following code below to our struct.</p><p>var locationManager = CLLocationManager()<br> func setupManager() { locationManager.desiredAccuracy = kCLLocationAccuracyBest locationManager.requestWhenInUseAuthorization() locationManager.requestAlwaysAuthorization() }</p><p>The code above is asking the user for permission so the location manager will know the devices location. There is an extra step here that we have to implement. We need to go into are info.plist and add a privacy property.</p><p>Hit the + button in the Information Property List and type "Privacy - Location When In Use Usage Description". On the right side add the message that will be displayed to your user to ask for their location. Then press enter and your plist should look like the image below.</p><img src="https://swifttom.com/wp-content/uploads/2020/03/screen-shot-2020-03-06-at-4.44.07-pm.png?w=1024"/><p>Now let's return to the MapView.swift File and get rid of these annoying error messages. These errors are because our MapView doesn't conform to the UIViewRepresentable protocol. Let's fix that now by adding the following code below.</p><p>func makeUIView(context: UIViewRepresentableContext<MapView>) -> MKMapView {
        setupManager()
        let mapView = MKMapView(frame: UIScreen.main.bounds)
        mapView.showsUserLocation = true
        mapView.userTrackingMode = .follow
        return mapView
    }
    func updateUIView(\_ view: MKMapView, context: UIViewRepresentableContext<MapView>) {
    }

Above we are adding the makeUIView() function and the updateUIView() function. These are both needed to conform to the UIViewRepresentable protocol. Inside the makeUIView() function we call the setupManger() function. We also initialize our mapview with the frame constrained to the whole screen and allow the map to show the user location. We also have the mapview track the user which allows the pin indicating where the user is to move with the user.

Now we can go to the ContentView.swift file and call our MapView.

struct ContentView: View {
    var body: some View {
        MapView()
            .edgesIgnoringSafeArea(.all)
    }
}

If we go and run this code now we should get an alert message for the user to allow the app to have access to the user location. Press allow and then we should see the map then load to the users location.

- ![](https://swifttom.com/wp-content/uploads/2020/03/simulator-screen-shot-iphone-11-pro-2020-03-06-at-16.57.25.png?w=473)
    
- ![](https://swifttom.com/wp-content/uploads/2020/03/simulator-screen-shot-iphone-11-pro-2020-03-06-at-16.57.34.png?w=473)
    

If you are using the simulator it will automatically use Apple's 1 Infinite Loop campus as the user location. If you run this code on your phone it will show you your location.

Awesome we are halfway done!

Next we are going add an annotation or pin to our app. In this example we are going to show how we can add a pin to ortega park in the top right corner of the above map.

First we will add a pin class to our MapView like the code below.

     class pin: NSObject, MKAnnotation {
      let title: String?
      let coordinate: CLLocationCoordinate2D
      
      init(title: String?, coordinate: CLLocationCoordinate2D) {
        self.title = title
        self.coordinate = coordinate
      }
    }

This is a simple pin (annotation) class that takes in a title and a coordinate.

Next we are going to create an array of our new Pin class like this.

@Binding var pins: \[Pin\]

We make it a @Binding this way it can keep the state of the pins consistent. Next we will update our mapview in the updateUIView() function to add our pins (annotations). Add the following code to our updateUIView() function.

    func updateUIView(\_ view: MKMapView, context: UIViewRepresentableContext<MapView>) {
        view.addAnnotations(pins)
    }

Now inside¬†our ContentView.swift file we will initialize an array of¬†pins. Then we will add¬†our Ortega Park pin to our map. Add the following code below.

struct ContentView: View {
       @State var pins: \[Pin\] = \[
      Pin(title: "Ortega Park", coordinate: .init(latitude: 37.342226, longitude: -122.025617)),
    \]
    var body: some View {
        MapView(pins: $pins)
            .edgesIgnoringSafeArea(.all)
    }
}

Now if we run our code we will see that we added a pin on Ortega Park .

![](https://swifttom.com/wp-content/uploads/2020/03/simulator-screen-shot-iphone-11-pro-2020-03-06-at-17.33.40-1.png?w=473)

Pretty cool!

We learned how to add a map to a view, display the users location, and showed how to add pins (annotations) to our map. I hope this article helps you get started on using maps in your SwiftUI projects.

All the code is [here](http://bit.ly/2wDN2Cc).

Happy programming üíªüë®üèª‚Äçüíª
</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-03-03-my-most-used-useful-keyboard-shortcuts-for-xcode-%F0%9F%92%BB</guid><title>"My Most Used/Useful Keyboard Shortcuts for Xcode üíª"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-03-03-my-most-used-useful-keyboard-shortcuts-for-xcode-%F0%9F%92%BB</link><pubDate>Tue, 3 Mar 2020 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>My Most Used/Useful Keyboard Shortcuts for Xcode üíª</h1><p>I love using keyboard shortcuts on my Macbook! I especially love using shortcuts in Xcode because it really helps my productivity. When using keyboard shortcuts I sometimes feel like I have magic powers being able to move around Xcode with ease. Below is a list of my most commonly used shortcuts.</p><p>For reference here are the Mac symbols used for these shortcuts.</p><p>Keyboard Cheat Sheet:<br>‚åò - Command<br>‚áß - Shift<br>‚å• - Option/Alt<br>‚åÉ - Control<br>‚á†‚á¢ - Left/Right Arrow Keys<br>‚á°‚á£ - Up/Down Arrow Keys<br>‚èé - Return<br>‚á• - Tab<br>‚éã - Escape</p><p>I recommend opening up a Xcode project and trying these out to see how each one works!</p><p>‚åò + R - Used for running your code</p><p>‚åò + N - Create a new file</p><p>‚åò + ‚áß + N - Create a new project</p><p>‚åò + ‚å• + 0 - Show and hide Inspector</p><p>‚åò + ‚áß + Y - Show and hide debugger console</p><p>‚åò + 0 - Show and hide Navigator</p><p>‚åò + F - Search a file for a particular thing</p><p>‚åò + ‚áß + F - Search the whole project for anything</p><p>‚áß + ‚åò + O - To open a file quickly (Great way to navigate if you know what file you are looking for)</p><p>‚åò + ‚áß + K - Cleans the folder your working in from its warnings and errors. This is useful when you‚Äôre pretty sure the code you wrote is correct, but when you run it, something is broken</p><p>‚åò + ‚áß +‚å• + K - Clean All files and build folder</p><p>‚åÉ + I - This will align your code and make whatever code you have highlighted look nice and clean</p><p>‚åò +‚å• + ‚èé - If you are using SwiftUI this will toggle your preview canvas</p><p>‚åò + / - Comment and uncomment code</p><p>*<em>‚åò + *</em> - Add a breakpoint to the current line of code</p><p><strong>‚åò +</strong> Y - Enable or disable all breakpoints (I use this all the time when debugging code)</p><p><strong>‚åò + .</strong> - Stop the current code that's running</p><p>‚åò + L - Jump to a particular line in that files code</p><p>‚åò + ‚áß + L - Brings up the Library</p><p>For a more complete list of keyboard shortcuts check our <a href="https://apple.co/32GK9wl">Apples documentation</a>.</p><p>I hope this helps make you a wizard of Xcode üßô‚Äç‚ôÇÔ∏è! Happy programming!!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-02-25-how-to-use-random-and-shuffle-in-swift</guid><title>"How to Use .random and .shuffle in Swift"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-02-25-how-to-use-random-and-shuffle-in-swift</link><pubDate>Tue, 25 Feb 2020 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>How to Use .random and .shuffle in Swift</h1><p>This is a short tutorial about how to use random and shuffle in swift. Let's get started by opening up a swift playground in Xcode or on the iPad. Copy the code below into your playground</p><p>// 1 var randomNumbersArray: [Int] = [] // 2 for _ in 0...24 { // 3 let randomNumber = Int.random(in: 1...100) // 4 randomNumbersArray.append(randomNumber) }</p><p>print(randomNumbersArray) // OUTPUT: [81, 36, 37, 25, 18, 52, 58, 99, 13, 31, 8, 21, 12, 56, 45, 26, 52, 50, 12, 78, 31, 39, 31, 45, 1]</p><p>// 1 Above we setup and <strong>randomNumbersArray</strong>. Which is just and array of Ints.</p><p>// 2 Next we set a For Loop that will loop 25 times.</p><p>// 3 Each time the loop runs we add one random number between 1 and 100.</p><p>// 4 Then we added the random number to the <strong>randomNumbersArray</strong>.</p><p>If you copy the code above into your swift playground you will get a different print statement then me because we are using <strong>.random</strong>!</p><p>Pretty cool!</p><p>We can also use the <strong>.random</strong> on a bool as well. Let's say you wanted to make an app that flips a coin.</p><p>let coinFlip = Bool.random() print(coinFlip) //OUTPUT: False</p><p>Each time you run the code you have a 50/50 chance of getting either true or false.</p><p>We can also use <strong>.random</strong> on doubles as well to get thinks like random percentages.</p><p>let randomDouble = Double.random(in: 0...1) print(randomDouble) //OUTPUT: 0.4773190050526464</p><p>If you run the code above then you can take the decimal you have and multiply it by 100 and now you have random percentages you can use for maybe a gaming app.</p><p>What if you just want to get a random element from an array you already have? Well we can use the code below to accomplish this task.</p><p>if let randomElement = randomNumbersArray.randomElement() { print(randomElement) } //OUTPUT: 26</p><p>Note that we use a <strong>if let</strong> statement unwrap the array because the array is optional and we don't know the array is nil.</p><p>Lastly let's go over <strong>.shuffle</strong>. Shuffle allows us to make a random set of data. To show this add the following code below.</p><p>// 1 randomNumbersArray.sort() // OUTPUT: [1, 5, 8, 12, 12, 15, 24, 24, 29, 31, 32, 32, 35, 45, 46, 47, 53, 65, 66, 70, 82, 88, 91, 92, 98] // 2 randomNumbersArray.shuffle() // OUTPUT:[65, 24, 32, 31, 12, 70, 66, 47, 5, 88, 45, 24, 46, 1, 53, 35, 91, 92, 15, 32, 82, 8, 12, 29, 98]</p><p>// 1 In the code above we first make order of the array with <strong>sort()</strong> so that we can demonstrate how shuffle works. The sort function just orders the arrays values from smallest to largest.</p><p>// 2 Now we have a shuffled array!</p><p>This was just a quick tutorial of how <strong>.shuffle</strong> and <strong>.random</strong> can be very powerful and convenient Swift functions. Also If you are like me and like to learn by from video tutorials please check out this <a href="http://bit.ly/394f488">tutorial by Sean Allen</a> which inspired this post! Happy coding! üë®üèª‚Äçüíªüíª</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-02-22-what-is-a-lazy-var-how-do-you-use-a-lazy-variable</guid><title>"What is a Lazy Var? How Do You Use a Lazy Variable?"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-02-22-what-is-a-lazy-var-how-do-you-use-a-lazy-variable</link><pubDate>Sat, 22 Feb 2020 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>What is a Lazy Var? How Do You Use a Lazy Variable?</h1><p><strong>Lazy</strong> variables in swift allow us to delay the creation of objects and only use them when the app needs them. <strong>Lazy</strong> variables help to utilize memory for expensive processes.</p><p>Lets see how we can use <strong>lazy</strong> in our apps.</p><p>import UIKit</p><p>struct MobileDeveloper { lazy var iOSDev: String = { return "I am an iOS developer" }()</p><p>lazy var androidDev: String = { return "I am an Android developer" }()<br> mutating func mobileDev(isiOSDev: Bool) -&gt; String { if isiOSDev { return iOSDev } else { return androidDev } } }</p><p>var person1 = MobileDeveloper() person1.mobileDev(isiOSDev: true)</p><p>// Output: "I am an iOS developer"</p><p>Above is a struct called Mobile Developer. Inside the struct we create two <strong>lazy</strong> variables that return if the mobile developer is a iOS Developer or a Android Developer.</p><p>We use the <strong>lazy</strong> syntax above because the Mobile Developer struct will only be set to one kind of developer, so we don't want to initialize both and waste any memory. Whichever variable is called on in the function will initialize what kind of developer is set to our person variable.</p><p>Below is another example given by Paul Hudson from his <a href="https://www.hackingwithswift.com/example-code/language/what-are-lazy-variables">article</a> on Lazy variables.</p><p>struct Person { var age = 16</p><p>lazy var fibonacciOfAge: Int = { return fibonacci(of: self.age) }()</p><p>func fibonacci(of num: Int) -&gt; Int { if num &lt; 2 { return num } else { return fibonacci(of: num - 1) + fibonacci(of: num - 2) } } }</p><p>In Paul's example he uses a <strong>lazy</strong> variable to determine what the fibonacci number would be for a particular age.</p><p>This is a great example of when to use a lazy variable because as the age variable gets higher the fibonacci function will take longer to figure out the right number to match with the age.</p><p>Paul's example shows by making a lazy variable we are not using unnecessary processes if we don't need to determine the fibonacci age. This makes the code really fast if we don't need to process the fibonacciOfAge variable.</p><p>Lazy variable are an amazing tool to use in swift for making your code super fast and efficient. I hope this article helps you on your coding journey! Happy Programming! üë®üèª‚Äçüíªüíªüë®üèª‚Äçüíª</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-02-19-how-to-use-map_-in-swift</guid><title>"How to Use .map(_:) in Swift"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-02-19-how-to-use-map_-in-swift</link><pubDate>Wed, 19 Feb 2020 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>How to Use .map(_:) in Swift</h1><p>In this tiny tutorial we are going to learn how to use the map() in Swift. The map() function is used to iterate and transform elements in an array. To get a better understanding of this let's look at some examples.</p><p>Let's say we have an array like the one below.</p><p>var names = ["tom", "steve", "jony", "woz", "swift"]</p><p>If we wanted to capitalize each name in the array we would have to use a For Loop with the <strong>.capitalized</strong> function in swift.</p><p>var names = ["tom", "steve", "jony", "woz", "swift"] var tempArray = [String]()</p><p>for name in names { tempArray.append(name.capitalized) names = tempArray }</p><p>print(names) //Output ["Tom", "Steve", "Jony", "Woz", "Swift"]</p><p>With map() we can complete the same task of capitalizing each name with less code. Below is the code we would use.</p><p>var names = ["tom", "steve", "jony", "woz", "swift"]</p><p>let capitalizedNames = names.map { (name) -&gt; String in return name.capitalized }</p><p>print(capitalizedNames) //Output ["Tom", "Steve", "Jony", "Woz", "Swift"]</p><p>What is going on in the code above is the map() function can be used with a closure. Basically we are doing the same as the For Loop by creating a parameter called <strong>name</strong> and returning a <strong>string</strong>. Here we are returning the iterated element only capitalized just like in the previous example.</p><p>We can even break this code down further into a one liner if we wanted to like the code below.</p><p>var names = ["tom", "steve", "jony", "woz", "swift"]</p><p>let capitalizedNames = names.map { $0.capitalized }</p><p>print(capitalizedNames) //Output ["Tom", "Steve", "Jony", "Woz", "Swift"]</p><p>This is very similar to the last example the only difference is that in the closure we use the $0 to represent the iterated item in the loop and we tell it to set it as capitalized. The $0 is a shorthand in swift programming but can be unclear and not very readable to some so I prefer the long form.</p><p>I hope this short article gives you some closure on what is map() function.</p><p>Happy programming üíªüíªüíª</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-02-12-how-to-make-a-image-carousel-in-swiftui</guid><title>"How to Make a Image Carousel in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-02-12-how-to-make-a-image-carousel-in-swiftui</link><pubDate>Wed, 12 Feb 2020 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>How to Make a Image Carousel in SwiftUI</h1><p>Today we are going to learn how to make an image carousel for displaying images in your app. Image carousels are a great way to show your user multiple images with only using a small amount of screen real estate.</p><p>To start lets create a new Xcode project and in your ContentView.swift file add the following boilerplate code.</p><p>struct ContentView: View { var body: some View { ScrollView { // ImageCarouselView Will Go Here.<br> VStack(alignment: .leading, spacing: 10) { HStack { Image("swiftTom") .resizable() .scaledToFill() .frame(width: 55, height: 55) .clipShape(Circle()) .shadow(radius: 4)<br> VStack(alignment: .leading) { Text("Written By") .foregroundColor(.gray) Text("Thomas Prezioso Jr") } }<br> Text("Feb 10 2020") .foregroundColor(.gray)<br> Text("How to Make a Image Carousel in SwiftUI") .bold()<br> Text(loremIpsum) .lineLimit(nil) } .padding(.horizontal) .padding(.top, 16.0) }.edgesIgnoringSafeArea(.all) } }</p><p>let loremIpsum = """ Lorem ipsum dolor sit amet consectetur adipiscing elit donec, gravida commodo hac non mattis augue duis vitae inceptos, laoreet taciti at vehicula cum arcu dictum. Cras netus vivamus sociis pulvinar est erat, quisque imperdiet velit a justo maecenas, pretium gravida ut himenaeos nam. Tellus quis libero sociis class nec hendrerit, id proin facilisis praesent bibendum vehicula tristique, fringilla augue vitae primis turpis. """</p><p>Above is just some boilerplate code to setup our app. If you run the app right now you will see we just added a picture with some text (Feel free to use any image you want in throughout this example. I am using some pictures that I had downloaded on my desktop of some baby huskies üòÖ).</p><p>Later we will add our Carousel View in between the ScrollView and the VStack in the ContentView file.</p><p>Now we are going to create a new SwiftUI file and name it ImageCarouselView. Then add the following code to our new ImageCarouselView.swift file.</p><p>import SwiftUI import Combine</p><p>struct ImageCarouselView<Content: View>: View {
    private var numberOfImages: Int
    private var content: Content

    @State private var currentIndex: Int = 0
    
    private let timer = Timer.publish(every: 3, on: .main, in: .common).autoconnect()

    init(numberOfImages: Int, @ViewBuilder content: () -> Content) {
        self.numberOfImages = numberOfImages
        self.content = content()
    }

    var body: some View {
        GeometryReader { geometry in
            HStack(spacing: 0) {
                self.content
            }
            .frame(width: geometry.size.width, height: geometry.size.height, alignment: .leading)
            .offset(x: CGFloat(self.currentIndex) \* -geometry.size.width, y: 0)
            .animation(.spring())
            .onReceive(self.timer) { \_ in
                
                self.currentIndex = (self.currentIndex + 1) % 3
            }
        }
    }
}

First we import SwiftUI and Combine.

Next we make a Struct called ImageCarouselView.

After that we added a variable called **content** which makes a reference to what images are going to be displayed. We also added a variable to keep track of the number of images we want to display with the **numberOfImages** variable.

Then we added a **@State** variable to keep track of our current index of which image is to be shown.

We also made a **timer** variable that every 3 seconds will automatically fire and queue the next image to appear on screen.

Next we created a custom init that will take in the number of images and image content variables. (The **ViewBuilder** you see in our parameters allows us to create a custom view container to render our view)

Inside the body we added a **GeometryReader**. We need the **GeometryReader** to get the parent view's frame.

We then used a HStack that will hold our images we want to display. We set the HStack spacing to 0 so the edges of each image will line up.

Next we added the **self.content** to display our image.

Then we set the frame for our HStack to the width and height of the parent view this way we only show one image at a time.

We created a **.offset** that takes in the currentIndex variable and multiplies it by negative value of the parents width to get our new offset. This will allow the next image to slide into the same space where the first image was previously.

We also added a spring animation so that the transition isn't rough or make the user feel like the app is broken.

And lastly we added **.onReceive** which takes in the **timer** so it knows to switch the image every 3 seconds and also updates the current range with a simple module operator. This keeps our range of images in between 0 - 2.

Now we can go back to our ContentView file and add the following code right under our Scrollview in the body.

GeometryReader { geometry in
                ImageCarouselView(numberOfImages: 3) {
                    Image("husky-1")
                        .resizable()
                        .scaledToFill()
                        .frame(width: geometry.size.width, height: geometry.size.height)
                        .clipped()
                    Image("husky-2")
                        .resizable()
                        .scaledToFill()
                        .frame(width: geometry.size.width, height: geometry.size.height)
                        .clipped()
                    Image("husky-3")
                        .resizable()
                        .scaledToFill()
                        .frame(width: geometry.size.width, height: geometry.size.height)
                        .clipped()
                }
            }.frame(height: 300, alignment: .center)

What's happening above is we create a **GeometryReader** and then call our custom init to get our image carousel. We create 3 child views of the parent that are all images.

We then set the images with resizable, scaledToFill, and set the frame to the parent view frame.

And that's pretty much all there is to it. If you build and run you should see the 3 images moving every 3 seconds followed by the boilerplate text we started with.

![](https://swifttom.com/wp-content/uploads/2020/02/carouselforblog.gif?w=496)

üéâ Congrats! üéâ We made a awesome Image Carousel! I hope this article helped you! Happy Programming! üë®üèª‚Äçüíªüë®üèª‚Äçüíªüë®üèª‚Äçüíª
</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-02-06-how-to-share-content-in-your-app-using-uiactivityviewcontroller-in-swiftui</guid><title>"How to Share Content in Your App Using UIActivityViewController in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-02-06-how-to-share-content-in-your-app-using-uiactivityviewcontroller-in-swiftui</link><pubDate>Thu, 6 Feb 2020 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>How to Share Content in Your App Using UIActivityViewController in SwiftUI</h1><p><strong>UIActivityViewController</strong> is a class that makes sharing content to other services on your apple device super simple. All you need to do is tell it what kind of content you want to share and <strong>UIActivityViewController</strong> take care of most of the heavy lifting. Here is how to implement it.</p><p>First we need to <strong>import UIKit</strong> to get access to <strong>UIActivityViewController</strong>. Then we are going to add the following struct to our code outside of our <strong>ContentView</strong>.</p><p>struct ActivityViewController: UIViewControllerRepresentable {</p><p>var itemsToShare: [Any] var servicesToShareItem: [UIActivity]? = nil</p><p>func makeUIViewController(context: UIViewControllerRepresentableContext<ActivityViewController>) -> UIActivityViewController {
        let controller = UIActivityViewController(activityItems: itemsToShare, applicationActivities: servicesToShareItem)
        return controller
    }

    func updateUIViewController(\_ uiViewController: UIActivityViewController, context: UIViewControllerRepresentableContext<ActivityViewController>) {}

}

What this struct is doing is setting itself as a **UIViewControllerRepresentable** so we can gain access to UIKit's classes. Next we are setting up our variables **itemsToShare** and **servicesToShareItem**. The variable **itemsToShare** is for our content that we want to pass to other services and **servicesToShareItem** is to get a list of service we can uses to share our content.

Next we setup the **makeUIViewController** function. This is where we sent the context to **UIActivityViewController** so it can be displayed in SwiftUI. Then inside of the function we set our **UIActivityViewController** with the content (****itemsToShare****) and the list of services (****servicesToShareItem****) we want to display in the controller. We also added **updateUIViewController** function to keep the Controller up to date with any changes.

Now we are going to go to the ContentView and add the following code.

struct ContentView: View {
    
    @State private var isShareViewPresented: Bool = false
    
    var body: some View {
        Button("Share") {
            self.isShareViewPresented = true
        }
        .sheet(isPresented: $isShareViewPresented, onDismiss: {
            print("Dismiss")
        }, content: {
            ActivityViewController(activityItems: \[URL(string: "https://www.swifttom.com")!\])
        })
    }
    
}

First we added a @State variable to keep track of presenting our share sheet. Next we create a button called "Share" and set our **@State** property to true if the button was tapped. Then we add the **.sheet** which tracks our state property and presents or dismisses our ActivityViewController. In this example we are sharing a url to this site.

When we run the code you should see something like below.

![](https://swifttom.com/wp-content/uploads/2020/02/simulator-screen-shot-iphone-11-pro-2020-02-06-at-17.25.29.png?w=473)

![](https://swifttom.com/wp-content/uploads/2020/02/simulator-screen-shot-iphone-11-pro-2020-02-06-at-17.25.41.png?w=473)

Just note that if you want to send content like an image or a video from your photos app you need to get permission from the user. You'll need to add the following to your **Info.plist** file.

- Open your **Info.plist** file.
- Click **+** icon.
- Choose the **Privacy - Photo Library Additions Usage Description** key.
- Set the value to **We need access to your photos gallery**

That's all there is too it! I happy coding! üë®üèª‚Äçüíªüì±üíª
</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-01-14-understanding-when-to-use-property-wrappers-in-swiftui</guid><title>"Understanding When to Use Property Wrappers in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-01-14-understanding-when-to-use-property-wrappers-in-swiftui</link><pubDate>Tue, 14 Jan 2020 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>Understanding When to Use Property Wrappers in SwiftUI</h1><p>What are property wrappers? Property wrappers in SwiftUI can be described as <em>@</em>State,¬†@Binding,¬†@ObservedObject,¬†@EnvironmentObject, and¬†@Environment. Let's go through each one and get a better understanding of how to use these property wrappers to help us program in SwiftUI.</p><p><strong>Property Wrappers</strong>:</p><p>Property Wrappers are defined as properties with logic which can be reused across different codebases.</p><p><strong>@State :</strong></p><p>@State is a one of the property wrappers in which we can use it to describe a views state. SwiftUI uses internal memory to store the state outside of the view struct. Only the view where the state is declared in has access to the state. When the state changes SwiftUI will rebuild the whole view to whatever the state has changed too.</p><p><strong>@Binding</strong> <strong>:</strong></p><p>@Binding creates a reference to a value similar to @State. Bindings are best explained and used in a example of a parent view having its state accessible to its child view. We use¬†$¬†symbol to pass a binding reference, because without¬†$¬†Swift¬†will pass the value as a copy of the value instead of passing bindable reference.</p><p><strong>@ObservedObject :</strong></p><p>@ObservedObject is like @State but can be used in multiple views. When that @ObservedObject changes SwiftUI will rebuild all views that have a reference to that object in it. SwiftUI¬†watches for the changes on¬†ObservableObject's¬†with the help of¬†@Published¬†property wrapper. @Published is the reference used to watch ObservableObject's, when a property marked with¬†@Published¬†changes¬†SwiftUI¬†rebuilds all¬†Views¬†bound to that¬†to that¬†object.</p><p><strong>@ EnvironmentObject :</strong></p><p>Instead of using¬†ObservableObject all over your app for updating views we can use the¬†@EnvironmentObject for¬†of our¬†view¬†hierarchy. By doing this, we create the opportunity for all children views to have¬†access¬†to our @EnvironmentObject. @EnvironmentObject¬†uses dynamic member lookup to find¬†class instances in the¬†environment. This helps in not having to pass the @EnvironmentObject from view to view.</p><p><strong>@Environment :</strong></p><p>Lastly the @Environment is a way we can easily access system-wide settings. Examples of system settings like Locale and Calendar are controlled with the @Environment property wrapper. If these system setting are to change SwiftUI will react and rebuild or view automatically.</p><p>These are property wrappers in SwiftUI. It can be confusing at first but the more you uses these property wrappers the better off you will be at knowing where and when to use them. I hope this helps to understand property wrappers in SwiftUI. Happy Coding! üë®üèª‚Äçüíªüì±üíª</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-01-14-using-urlsession-and-codable-to-retrieve-data-in-swift</guid><title>"Using URLSession and Codable to retrieve data in Swift"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-01-14-using-urlsession-and-codable-to-retrieve-data-in-swift</link><pubDate>Tue, 14 Jan 2020 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>Using URLSession and Codable to retrieve data in Swift</h1><p>How I learned to retrieve JSON data from API's was by using CocoaPods like <a href="https://github.com/Alamofire/Alamofire">AlamoFire</a> and <a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>. These Cocoapods make it easy to call an API for some piece of data but these libraries come with a lot of extra things I just don't use most of the time in my app. So now I have been trying to use Apple's solution by using Codable and URLSession.</p><p>As of Swift 4 Apple's Codable library with URLSession makes retrieve data as simple as a few lines of code. Let's take a dive into seeing how we can use these libraries to make a simple API call to retrieve my username from my Github account.</p><p>First we want to setup a struct that conforms to the Codable protocol. Add the following code to your swift file.</p><p>struct MyGitHub: Codable {<br> let name: String? let followers: Int?<br> private enum CodingKeys: String, CodingKey { case name case followers</p><p>} }</p><p>In the code above we are make a simple struct with two variables, name as a string and followers as a Int. Below this we created a enum called "CodingKeys". What this does it make it so that whatever the key value name is of the object we want in the data, will automatically be assign to the corresponding variable object with the same name.</p><p>So "name" in the JSON will automatically be assigned to our name variable in our MyGitHub struct (Same goes for our followers variable). If we wanted an object from our JSON data that had a key name with two or more strings separated by "_", we would set the variable name to match the JSON datas string like the code below to assign the object to our variable.</p><p>private enum CodingKeys: String, CodingKey { case name case followers case repos = "public_repos" case avatarUrl = "avatar_url" }</p><p>Next we are going to need to create a function that makes the call to the URL so we can get my GitHub username. Added the following function to our code and we will go through what's going on here.</p><p>func fetchDataFromApi() {<br> guard let gitUrl = URL(string: "https://api.github.com/users/tprezioso") else { return }<br> URLSession.shared.dataTask(with: gitUrl) { (data, response, error) in<br> guard let data = data else { return }<br> do { let decoder = JSONDecoder() let gitData = try decoder.decode(MyGitHub.self, from: data) print(gitData.name ?? "Empty Name")<br> } catch let error { print("Error: ", error) } }.resume()<br>}</p><p>First we use a guard let statement on our URL variable to see if our URL is valid otherwise we return. Next we create a URLSession that takes in our URL variable with a closure that returns "data, response, error" data. We then use guard let statement on the data to check if we have any data (You should add some sort of default error handling on any "guard let" statement but for this example I am skipping that üòÖ). If we do have data we then want to add a "Do/Catch" statement because we can have an error on the data that is returned.</p><p>Next we need to use JSONDecoder which will decode the JSON and match our MyGithub struct variables to the data variables we received. Next we add a print statement to print my username for GitHub to the console. Lastly we will add a catch statement to catch if there was an error, if any (We are awesome programmers and we don't make errors ü§• ).</p><p>Also don't forget that the end bracket of URLSession needs ".resume()" or else nothing will happen when you go to run your app.</p><p>Finally, all we need to do now is call our function from either "ViewdidLoad" if your using UIKit or ".onAppear()" if your using SwiftUI. Go ahead and run your code and you should see my name (or your name if you switched my handle with your github handle in the URL) in your console print out.</p><img src="https://swifttom.com/wp-content/uploads/2020/01/screen-shot-2020-01-21-at-6.08.41-pm.png?w=1024"/><p>With just a handful of lines of code we can get data from the web using Swifts Codable and URLSession. Hope this helps to simplify your code because it has helped me tons. Happy programming! üë®üèª‚Äçüíªüíªüì±</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-01-04-where-do-i-load-my-app-icon-for-a-stand-alone-watchos-app</guid><title>"Where Do I Load My App Icon for a stand alone WatchOS App?"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-01-04-where-do-i-load-my-app-icon-for-a-stand-alone-watchos-app</link><pubDate>Sat, 4 Jan 2020 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>Where Do I Load My App Icon for a stand alone WatchOS App?</h1><p>Recently I have been work on a little side project using SwiftUI in a stand alone watchOS app. When building my watchOS I was confused as to where I put the icon for my app since there are two Asset.xcassets file.</p><p>One asset file is in the main Watchkit project folder and the other can be found in the WatchKit project extension folder (This is the main area for coding your stand alone watchOS app).</p><p>The main Watchkit project folder is the one you want to add your app icon images too. Do yourself a favor and don't create your own like I did in the Watchkit extension and make a bunch of error messages popup. ü§¶üèª‚Äç‚ôÇÔ∏è</p><p>Hope this saves some people from some pretty bad headaches. Don't make the same mistake I did! Happy Coding! üë®üèª‚Äçüíªüíª ‚åöÔ∏è</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2020/2020-01-02-how-do-you-make-a-form-in-swiftui</guid><title>"How Do You Make a Form in SwiftUI?"</title><description></description><link>https://tprezioso.github.io/posts/2020/2020-01-02-how-do-you-make-a-form-in-swiftui</link><pubDate>Thu, 2 Jan 2020 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>How Do You Make a Form in SwiftUI?</h1><p>In this tutorial we are going to look at how to make a Form in SwiftUI. The Form view helps make things like sign in sheets very simple and fast to setup in your app. With just a few simple lines of code you will have a form up and running. Let's get started with making a contact form sheet.</p><p>Open a new Xcode project and in your ContentView file change the code to the following code below.</p><p>struct ContentView: View { var body: some View { NavigationView { Form { // Form fields go here }.navigationBarTitle(Text("Contact Info")) } } }</p><p>Above we added a NavigationView so we can have a nice Navigation title for our view. Then we added the Form view so we can setup taking in the information for our contact form.</p><p>Next we will add some text fields so we can take in a first name and a last name for our contact form. First we will make state variables for our first and last name text fields outside of our body view.</p><p>@State private var firstname = "" @State private var lastname = ""</p><p>We make these @State properties so we can bind them to the text field views to update changes. Next we will add our text fields to our Form.</p><p>var body: some View { NavigationView { Form { TextField("Firstname", text: $firstname) TextField("Lastname", text: $lastname) }.navigationBarTitle(Text("Contact Info")) } }</p><p>If we run this code now you should get a view with our title view and two text fields. The text fields should show up one on top of the other with labels that say "First Name" and "Last Name".</p><img src="https://swifttom.com/wp-content/uploads/2020/01/simulator-screen-shot-iphone-11-pro-max-2020-01-01-at-19.59.27.png?w=473"/><p>Next in our contact form we will create a picker to set the primary way of getting in contact with this user. We will create a struct of primary contact options (added this code outside of our Struct for our Content view).</p><p>struct PrimaryContact { static let userPrimaryContact = [ "Phone Number", "Text Message", "Email", "Skype", "Carrier Pigeon" ] }</p><p>Next we will set up a State property for our primary way of getting in contact. Add the following code below the lastname state property.</p><p>@State private var primaryContact = ""</p><p>Now we will added our picker below our last name text field like this</p><p>var body: some View { NavigationView { Form { TextField("Firstname", text: $firstname) TextField("Lastname", text: $lastname) Picker(selection: $primaryContact, label: Text("Primary Contact")) { ForEach(PrimaryContact.userPrimaryContact, id: .self) { primaryContact in Text(primaryContact).tag(primaryContact) } } }.navigationBarTitle(Text("Contact Info")) } }</p><p>Above we are binding the picker to our primary contact state. When a primary contact is selected the changes will automatically be updated by the view.</p><p>Now when we run our app we should be able to see a picker view below our "First Name" and "Last Name" text field. When we tap on the "Primary Contact's" button we will see our preset primary contact preferences that we made in our struct. After you select one by tapping, we can go back to the main form view and see the one you selected shows up on the opposite side from the "Primary Contact" label.</p><img src="https://swifttom.com/wp-content/uploads/2020/01/simulator-screen-shot-iphone-11-pro-max-2020-01-01-at-20.01.57-2.png?w=473"/><img src="https://swifttom.com/wp-content/uploads/2020/01/simulator-screen-shot-iphone-11-pro-max-2020-01-01-at-20.02.01-1.png?w=473"/><img src="https://swifttom.com/wp-content/uploads/2020/01/simulator-screen-shot-iphone-11-pro-max-2020-01-01-at-20.02.56-1.png?w=473"/><p>Next we will add a very common form field which is a toggle view. This toggle will control if we want to share this contact publicly. Like we did with the picker view, we will first add a state property to handle any changes to our toggle.</p><p>@State private var publiclyShare = false</p><p>We set the state of the toggle to false otherwise the toggle would start out already being turned on in our form. Now we will add our toggle view to our form. Add the following code below the picker view.</p><p>Toggle(isOn: $publiclyShare, label: { Text("Publicly Share Contact") })</p><p>Like we did for the picker view we bind the toggle view with $publiclyShare variable to update our view if toggled. If you build and run now you will see our toggle view below our picker.</p><img src="https://swifttom.com/wp-content/uploads/2020/01/simulator-screen-shot-iphone-11-pro-max-2020-01-01-at-20.04.01-1.png?w=473"/><p>The last important form input field is a stepper view. We will add a contact rating as our stepper view (Always rate 5 stars to the contacts that you like üòÇ). Like we did previously we will again add some state to update the view when the user has tapped the stepper. Add the following code below your other state properties.</p><p>@State private var rating = 0</p><p>I set the rating to 0 for now but we will soon add a range from 0 - 5. Now added the following code underneath the toggle view code.</p><p>Stepper(value: $rating, in: 0...5, label: { Text("Rating: (self.rating)") })</p><p>Above we bind the stepper to our rating property. Then we provide the range for our ratings (0 - 5). And last we add a label to name our stepper.</p><p>If you run your app now you should see a stepper starting at 0. On the opposite side you should see the plus and minus symbol which on being tapped to should make our rating go up and down for our contact.</p><img src="https://swifttom.com/wp-content/uploads/2020/01/simulator-screen-shot-iphone-11-pro-max-2020-01-01-at-20.05.38-1.png?w=473"/><p>Below is the completed code for our SwiftUI Form file.</p><p>import SwiftUI</p><p>struct ContentView: View { @State private var firstname = "" @State private var lastname = "" @State private var primaryContact = "" @State private var publiclyShare = false @State private var rating = 0<br> var body: some View { NavigationView { Form { TextField("First Name", text: $firstname) TextField("Last name", text: $lastname)<br> // Picker Picker(selection: $primaryContact, label: Text("Primary Contact")) { ForEach(PrimaryContact.userPrimaryContact, id: .self) { primaryContact in Text(primaryContact).tag(primaryContact) } }<br> // Toggle Toggle(isOn: $publiclyShare, label: { Text("Publicly Share Contact") })<br> // Stepper Stepper(value: $rating, in: 0...5, label: { Text("Rating: (self.rating)") }) }.navigationBarTitle(Text("Contact Info")) } } }</p><p>struct ContentView_Previews: PreviewProvider { static var previews: some View { ContentView() } }</p><p>struct PrimaryContact { static let userPrimaryContact = [ "Phone Number", "Text Message", "Email", "Skype", "Carrier Pigeon" ] }</p><p>This is the basics to start building forms in your app. It pretty simple to create a form view in SwiftUI with not that much code. Hope this article helps you in you coding journey. Happy Coding!! üë®üèª‚Äçüíªüíªüì±</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2019/2019-12-26-navigating-from-one-view-to-another-with-navigationview-in-swiftui</guid><title>"Navigating from One View to Another with NavigationView in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2019/2019-12-26-navigating-from-one-view-to-another-with-navigationview-in-swiftui</link><pubDate>Thu, 26 Dec 2019 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>Navigating from One View to Another with NavigationView in SwiftUI</h1><p>In this article we are going to learn how to use the NavigationView library to navigate from one view to another in SwiftUI. We will look at the most basic way to transition from a view using a button and a NavigationLink.</p><p>First thing we will need to do is add NavigationView into our body view. In the code below we wrapped our Vstack in a Navigation View. Then we added a Navigation Link which will be our button to send us to the next view. The parameter in the NavigationLink is destination. We will set this to the view we want to see when the button is pressed.</p><p>import SwiftUI</p><p>struct ContentView : View { var body: some View { NavigationView { VStack { Text("Main Content View") .font(.largeTitle) Spacer() // Button to make a transition to the next view NavigationLink(destination: DetailView()) { Text("Detail View") .frame(minWidth: 0, maxWidth: 300) .padding() .font(.title) } } } } }</p><p>Next we will create a new SwiftUI file and name it DetailView. In your second view or DetailView we are just going to setup a text view so we have something to see when we transition to the new view.</p><p>import SwiftUI</p><p>struct DetailView: View { var body: some View { Text("I'm, The Detail View!") .font(.largeTitle) } }</p><p>If you run the code now you should see our main view text at the top with our Detail View button at the bottom. Tap on the button and we should be taken to the Detail view. You will notice that when we use NavigationView we get the back button when we transition for free so we can navigate back to our main view (You also get swipe to go back as well).</p><p>That's really all there is to setting up navigation in SwiftUI! Happy Coding! üíªüì±üë®üèª‚Äçüíªüéâ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2019/2019-12-17-how-to-run-and-debug-your-app-from-xcode-wirelessly-on-your-device</guid><title>"How to run and debug your app from Xcode wirelessly on your Device"</title><description></description><link>https://tprezioso.github.io/posts/2019/2019-12-17-how-to-run-and-debug-your-app-from-xcode-wirelessly-on-your-device</link><pubDate>Tue, 17 Dec 2019 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>How to run and debug your app from Xcode wirelessly on your Device</h1><p>I recently purchased a new Mac and when transferring everything over from my old Mac to my new Mac I forgot to setup wireless debugging in Xcode. I love not having to have your iPhone or iPad connected to your Mac to run your code and debug. I have been taking advantage of this feature since WWDC 2017 and its become such a big part of how I test and run my code on my devices. When I didn't have this feature turned on in Xcode on my new Mac I thought something was broken or wrong with Xcode. Once you have this enabled you will feel the same way!</p><p>Lets see how we go about setting up one of my favorite features in Xcode.</p><ol><li>Open your Xcode project</li><li>Connect your iPhone or iPad with your computer (One time only)</li><li>In the menu bar at the top open Window &gt; Devices and Simulator</li></ol><img src="https://swifttom.com/wp-content/uploads/2019/12/screen-shot-2019-12-17-at-6.32.38-pm.png?w=1024"/><p>You should see your device connected in the Devices tab.</p><p>4. Click on the devices tab if you have not and check the little box next to your device that says "Connect via network"</p><img src="https://swifttom.com/wp-content/uploads/2019/12/screen-shot-2019-12-17-at-6.33.39-pm-1.png?w=1024"/><p>Your all set!</p><p>Pretty easy!</p><p>5. Now you should be able to unplug your device and hit run on your Xcode Project and it should run on your device without a cable!</p><p>Congrats! Enjoy all the sweet wireless debugging life! üéâüë®üèª‚Äçüíªüíªüì±</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2019/2019-12-14-how-to-know-when-a-user-is-having-a-first-time-launch-of-your-ios-app</guid><title>"How to know when a user is having a first time launch of your iOS app?"</title><description></description><link>https://tprezioso.github.io/posts/2019/2019-12-14-how-to-know-when-a-user-is-having-a-first-time-launch-of-your-ios-app</link><pubDate>Sat, 14 Dec 2019 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>How to know when a user is having a first time launch of your iOS app?</h1><p>The first time launch in an application is important for displaying things like tutorials to teach the user how to use your application or showing terms and service agreements. The problem is how do you know when was the users first time launching your app. For the best way to implement this we will need to head over to the AppDelegate.swift file. Then we will need to create a global variable outside of the AppDelegate methods like this.</p><p>var firstTimeLaunch: Bool!</p><p>Now that we have our global boolean, we will need to use the UserDefaults class to set and store the firstTimeLaunch boolean. We do this so we know if the use has launched the app before. Inside of the didFinishLaunchingWithOption method add the following code.</p><p>firstTimeLaunch = UserDefaults.standard.bool(forKey: "firstTimeLaunch")</p><p>// Check for first time launch of app if (firstTimeLaunch) { firstTimeLaunch = true } else { UserDefaults.standard.set(true, forKey: "firstTimeLaunch") }</p><p>Above we are just making a simple check to see if it is the first time the user is opening the app. Then we are storing the boolean value in UserDefaults class so that on a relaunch of the app the bool will be read from memory if the user has open the app before. Also we will setup a function in the AppDelegate to set our boolean if firstTimeLaunch has happen. Add this code below to your Appdelegate.</p><p>func firstTimeLaunchHasAlreadyLaunched(){ firstTimeLaunch = true }</p><p>Now go back into your main ViewController file we are using at launch and we are going to make an instance of AppDelegate.</p><p>let appDelegate = UIApplication.shared.delegate as! AppDelegate</p><p>Then we will use the the viewDidAppear method and setup our check for if a first time launch of the app has occurred.</p><p>override func viewDidAppear(_ animated: Bool) { if(!appDelegate.firstTimeLaunch){<br> //set firstTimeLaunchHasAlreadyLaunched to false appDelegate.firstTimeLaunchHasAlreadyLaunched()</p><p>// Below display the view you want on the first time in app below /* Code here */ } }</p><p>Now if you let your code run, in your app you should see the view you want to display on the first time launch of your app. When you close the simulator and run it again the view will no longer appear. Its as simple as that! Happy Swift Programming üë®üèª‚Äçüíª!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2019/2019-11-19-how-to-display-a-modal-view-in-swiftui</guid><title>"How to display a Modal View in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2019/2019-11-19-how-to-display-a-modal-view-in-swiftui</link><pubDate>Tue, 19 Nov 2019 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>How to display a Modal View in SwiftUI</h1><p>In SwiftUI, to present a modal view we need to use a new display modifier called sheets. To present a view modally we first need to start by creating a new SwiftUI file and name it ModalPresentedView. Go to File &gt; New &gt; File and choose iOS &gt; User Interface &gt; SwiftUI View. Then add the code below to our Modal view.</p><p>struct ModalPresentedView: View { @Binding var showModal: Bool<br> var body: some View { VStack { Text("Inside Modal View") .padding() Button("Dismiss") { self.showModal.toggle() } } } }</p><p>What we are doing in the code above is adding a binding property which will be used toggle the modal view to show and dismiss. I also added a button to dismiss the modal view.</p><p>Next we will change the code in the content view file to present our new modal view.</p><p>struct ContentView: View { @State private var showModalView = false<br> var body: some View { Button("Show View") { self.showModalView.toggle()<br> }.sheet(isPresented: $showModal) { ModalPresentedView(showModal: self.$showModal) } } }</p><p>What we did in the above code is we added a state property which will control the presenting of the modal view when toggled. We also added a button that toggles the state of our modal view and presents it with the sheet modifier.</p><p>Now press the resume button in the canvas view. Press the play button to run a live preview of your code and you should have the ‚Äúshow modal‚Äù button to present the modal. A swipe down will dismiss the modal or you can use the ‚ÄúDismiss‚Äù button to remove the view.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2019/2019-11-18-swiftui-on-ipad-in-swift-playgrounds</guid><title>"SwiftUI on iPad in Swift Playgrounds"</title><description></description><link>https://tprezioso.github.io/posts/2019/2019-11-18-swiftui-on-ipad-in-swift-playgrounds</link><pubDate>Mon, 18 Nov 2019 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>SwiftUI on iPad in Swift Playgrounds</h1><p>Did you know that you can write SwiftUI code on your iPad! Apple‚Äôs update to Swift Playgrounds on the iPad now supports SwiftUI! This means we can build SwiftUI components anywhere we can take our iPads. This is really exciting because this brings developers one step closer to making iOS apps on the iPad (One day we will get Xcode for iPad üòï).</p><p>This is how you get started coding on your iPad with SwiftUI. Open a Blank Playground and add the boilerplate code below to your Playground.</p><p>import SwiftUI import PlaygroundSupport</p><p>struct ContentView: View { var body: some View { Text("Hello World") } }</p><p>PlaygroundPage.current.setLiveView(ContentView())</p><p>Don't forget to hit the "Run Code" button but thats all there is to start writing SwiftUI components on your iPad. Happy iPad coding!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2019/2019-11-05-how-to-get-text-to-wrap-around-in-a-scrollview-in-swiftui</guid><title>"How to get text to wrap around in a ScrollView in SwiftUI"</title><description></description><link>https://tprezioso.github.io/posts/2019/2019-11-05-how-to-get-text-to-wrap-around-in-a-scrollview-in-swiftui</link><pubDate>Tue, 5 Nov 2019 00:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>How to get text to wrap around in a ScrollView in SwiftUI</h1><p>As of this posting I was having a problem with an Apple Watch app I was trying to make using SwiftUI. The problem was text was not wrapping around my view that was nested in a ScrollView and VStack. I found that by adding these modifiers to your text will giving you multiple lines for text! Happy Coding!</p><img src="https://swifttom.com/wp-content/uploads/2019/11/screen-shot-2019-11-05-at-4.16.27-pm.png?w=744"/>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2019/2019-10-26-example-post</guid><title>"What is a SceneDelegate in Swift?"</title><description></description><link>https://tprezioso.github.io/posts/2019/2019-10-26-example-post</link><pubDate>Sat, 26 Oct 2019 00:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>What is a SceneDelegate in Swift?</h1><p>In short the SceneDelegate.swift file is there to help with the new multi-window support that was announced with iOS 13.</p><p>The UISceneDelegate protocol is used to manage the life cycle for one instance of your app. Apple gave a good example of this when showing multiple instances of their notes app in split screen alongside other apps at the <a href="https://developer.apple.com/videos/play/wwdc2019/212/">WWDC keynote</a>.</p><p>Think of SceneDelegate as a offshoot of the AppDelegate. The AppDelegate will still handle things like configuring the initial scenes and register for services like push notifications but now the AppDelegate will be sharing its responsibility of the apps life cycle with the SceneDelegate.</p><p>Things like state transition methods or life cycle methods that use to be handled in the AppDelegate, like "will enter foreground", "will become active", and "when it enters the background" are now handled in the SceneDelegate.</p><p>For a more indepth look into the SceneDelegate and all the changes to the AppDelegate I recommend reading this great <a href="https://learnappmaking.com/scene-delegate-app-delegate-xcode-11-ios-13/">article by Reinder de Vries</a>. Reinder takes a deep dive look into how to get started using the SceneDelegate and what has changed in iOS 13.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://tprezioso.github.io/posts/2019/2019-10-02-welcome-to-my-blog</guid><title>"Welcome!"</title><description></description><link>https://tprezioso.github.io/posts/2019/2019-10-02-welcome-to-my-blog</link><pubDate>Wed, 2 Oct 2019 01:00:00 -0400</pubDate><content:encoded><![CDATA[<h1>Welcome!</h1><img src="https://swifttom.com/wp-content/uploads/2019/10/img_8186-1.jpg?w=768"/><p>Hi! My name is Tom, I am a self taught programmer that has been programming since 2015. This blog is to help teach swift programming topics to anyone who wants to learn how to program in swift. Topics covered on this blog will range from beginner to experienced. Come join me in learning all about the amazing programming language that is swift!</p>]]></content:encoded></item></channel></rss>